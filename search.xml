<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pomodoro Daily Plan</title>
      <link href="/2025/02/26/%E6%AF%8F%E6%97%A5%E4%BA%8B%E9%A1%B9/"/>
      <url>/2025/02/26/%E6%AF%8F%E6%97%A5%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6415c94e3afa233f5dd100734e728c5fc5aa64f2e0e0ff61d7e313f7a3a51774">7270f71a1e1dda70b94ec6921889be065fd9138db38680dd6f18788bd85b8a24388682f84bd7de1f4d42f7650a7e6b2e88459223b5ce10c499c00f556a11deb4a90a45c4fabe8a262351b4e3481e0f5acad539d5cb019d929f8c11b1285599b66039978af52cc6bc2c0105e51114fb2a5769aae2166950eae50f6ab3186e8e2790d128664f5264fa1e417232d207fe9efab594ccde595959a8a4c3293a9817512c62f34cd77f471e6022bbcfddf4dbf05a3cf2e90526231a1eca80ba841463258622888e88a90ec1d1b0f6244399e0c47b6be4477a4280686f317bed930cea4f216280f53fc4a477e7399b720daafee798818ddf8df5c19ad3c79747eb5daa030a0638d9a24862436857005887c57e72b2ea2b1f2822d9932965a577ec695813762f67d98bf1ce93341fdeca0a802f6f7f4baf253cb8e0d71ccbbc865dd3bda7417a18ef4846b2e53351b5f9707a8edce697cb2b4670c73c8ec07059fcea8586b39aa7633b82b8443bbc766940c6fb5f5729f21274ef5d1259ce8a456339d0fb648dda4ae84955c7598e1b6acd73b6ce374bafc2f7d31c2093c5c5ed338b1dbcaa2a9db2c11b67a630237addd1ccef6e1c3cb73b44ad010d3a895df1877267f1a863d844c8f43777f0ebbc233b5cf85b4157ecf556f38e0f79cc4e3b205d0f1dc2965b7465dacc777cde4da94ef67828fdd10ce6af7f3690121bcffbae00c4dfa99a9ec1cbebfebc57c36787a7e7ad6c818609f7a7fe430657fa2fa9deeb779a2d39e17326f3ee234304ba519e42ff582a7c721ecf470d4a7e61c46fb86ee5f7d7431f088a8526073ed97d1977da8e1adf600e084a1516a9760e330d030d78b5830a6bf5aee2497464c3cff7c6fb1e6380d3ee8fd25201b2769989b59702c980b6f7eacdbd20dc59252c8eb1ba98b8720fa3d0da2a6b2129c1f0ff7bec03f075c13125855f9468876398f671f364434d090dbd24bf27b679d5ddf5e3dfa1257f7421ab9b9eaa0ad8f6ccce8cd3aea9f44215b5ad9b1deb614e1fe772e2cf604582ee02ef5dcedbb22ee590edb2f21604ae00507f9b277247154f72a5e2c69fea45b3506ba1c278fb4882ee06d7f631eca5309a92989e872f499e1f60e9e7a8a86677710193b8e2afaeedbd7b17a9a3cd481db9836d0ac75875ff289ee85e6f8dcbed1e079bef0f1289debd4250116938157057e4695c3f797ea2d989c2ae9d0f668e2a1a2a8d81b0e782131c5e7ef5b78ca6091219aa8c867ec5891633a19645ac4a6cfcbb726986def79e558f27f08eac2b892cb7fb4e86707128ca9917eaa9709d6a8c1b21790cac0bc9ffa334bceb4f9955301cf74cc90a5c2faec54572df871a35fb0ad98da34e63899df844cab9645b6d53baf72e350979904994103f34326c4361e5a88aa98de88d6c8fcf40c32fe6b5a6c09324f84706947706b05d45a4ef104f053e67e9df239b2bcb448a19621d676df7332f66274ef30a0a9d3a1c894e258ad16d5d3a4109230f0ca754663672469e6ba712a8a345e6f0af63e4064c6986049bfea5768763aeea3cfa99a1abfde80244c6709514c3fa705b970e524856babad1481d9d8796399b052e6aededa4e409b183f9e3ecd2ba56ba21c3204cc56493c68058b966d214742b2b954be2c387651e49f55018275cf6e74253daedf894bfe87f4b64da954f9a61ad59561f0f8c89a9825f165fe17ae8a917296eab8787e8d5a6cf94ad2cfe860e191f8d6afebe07690acb523a2275723d0bb3b47bedb19666b3991ae02af8db1e57beb984d642f4a3aceddbe8310d6771838f47ca1b4ae0c08d39bd9ff8ba3ea3cbd29953266376afc6418fc8758d10d4bb353c2dbcdac10bc252c5e1021a270218f4f8673ee45c533ae5fbe46c3c585c0d1524c2c0022efcc994f4284ab4a5dc0ccfd379b50c57a9a128f1315d8553347abbe310e30ad4984bd939bd3ccfe8e87461c75d3bb76660c2803959aa69e18992d5b64008375b07771da6d263d36c0f4be9f1a6809f43c645dcbc222d1722ac0d0c9bcbe3657ea7cbd380b8c31b1624f0673af11351ee68006b872caafbd9837cfa6d0f28464116ee31cb24cb05ca2c4d7723cf5480f05dcaee6ef805f3b29c1e6793d051c2d5811d07eb03bcd030e4ae04925c0f08ca2c857bdfe116f6ac390c7aeab01fe17fb5402b9097b911314c940135ab7ff5c5c6a188496c8c14bd96b56a76ec8b87e73672a623bf1d61ace98e9c7fda50fed3758a1bf5cb6aeccc2343372ae97cd90010bac445ddf022b8c2e20235902a4c67912a79549e4a16305f5e8462e1a3969f6dbc4d7ba6856b57e5e11ff8b36f0ff437e05526b45657e42b2e59a3aea88b26b35e0a15bedf92812cf6d66f0d80da74d1a53e2588667c6812d6d0ffd5ba1f31879ddfadd842f88db01dd7b41ff8185afc7956d6657ee9b112cd8545f9f90eef9be03401c20e53b5a3940485d1870e369152a766133c4991b30805e87d12c94a81e52e8862ddf0eea0d78972d81b455f505130c3a44d479a7959037aea4a557203b5938201af84d1cd139fdd1debf7ef53fa5123ee76b1b10b2ccc3ea4c816d3700fb42e9d490e82cc525cbf5948e8fe2f813978aa427aacc76348206740d31a5ef2b554b589cf17a454fc133653a28c86a75eb6d643a09c013daba87c80978b00463e00a7b02a74d58f5e14b69a5aaa333b64bf3ab0125fc67c0136d2ba54d240dfafac7eb66d4309244a5756cee78e11320134d2c66933409bcb7c9e1e35d17a23c4e829df283f4a740e74d71e61c12634d97a8d014eaddd6042ad69c3e9ac09f0d6fc47aec413ebffc660fb71fb77bae570d79990f34d8b06a952a6395e57c8fec99a96ebd027cc6f43134909588373f2f986090047dfbfd49cfc2f1daf17de148735fa9b645cc04e30131d135f39de1d9473560e719d702d34d1e05e245809c8fbe9c4ef56664659ef0b569ba83c672d3b56b2a367182f75af655f01f0791de23032eae7791948bd005f2d2f8367671959498149f6ffe756df748f35e7d1f9ba5a1640101f827b9c1cdfa1604bf8198827e5eebaa24af7d9f17a0c0ea5d6efefbafd92cbb1358813bb3676133da37dd82f2b91fc06906616d015822d65c6e064d808484f7cff9483ed5995e3848248fd9a0d577f3623ababe8c58f512dc5b517275db20f257141902bc405edaaaf5d73b164e1aebf6310ec440e717e677d22c51eddc22eab8526069d7196f3b367f3279af87eff86e4f49a583f07d3c3b883de6870c5154034589500c4e212f26088e8b3477ea941f52d23645e50df690cd28782d48aa2451d152d73c757458fb1e481b354665f47a2773e09fa9280619529bf894e38ee5e4b3c4bca48a7b94af4eba78f239678b43c69b085d15f68202b93c73163df9ac43a2f14a0d2166edc2eed2f16864c6b509c7e592d511358f6648f617f8cbdbae025fd672d6ce2a1916f927476d00e8e899a465ed71fe8ed03a8fc8c1e794b67b409f16024204e53dc59410061c0b1fba7a3954ad8dbd2f5eff379b61c9f2404ef0d941a1cba49a550a14d6ac464209fa2e6b5bb9f904adaf08313549bee7f5d9040039dc23050ce59ad10136e3cc8ca3c04b12c96bcec3e7f4bae7090c77c20d4670c2bfcfc79d0de8552f65f6b65b2fac38fe92da76b2e7a6246187153564476edb86fc71860ec74a8470426046739d3c5723cf4de75f73d105587540f33934eb03462744eb96fe69a0abceee37824c36c4507576b2c4e48f60dbdb7ceff14badf08db563a0f3cbab143bb5c0fdb38dca0ca866b752e893a4c9d6dc8f071ca75afe9d6c884a320a936c13e5ec69b8a9b9d447eada9c1cf61f10f3e91a4edc1e4c77b6a716f041879008a8c2cf0ff57ec12a5d27d0a4f3c928de973920303750928903ef58cb3c3646e3f7fb819dfbc8ea9b5a00daf7d7d2c96d2fa3856c69a2b3e596d712b2cdd3204c51f90863303b4064a1a6d79a5350917210fb438c8b047c94e9fcb5de3c9290576c7e69d2b03cfd1bf4067068932a98f647e5d7415ad938d8fa28ebd765bc0c2cf4abbbc35f0db5ea57ee9e5fb3f3f2a90be7ffe209ad1a6cee152ace9204540bd065f15db289784e9f1df3652c81216f03bb48de31fa44212fc95ec6adc3b2f6405408ff5fe198b4762945f8651d536848d6cb7e22286428126189d4e6875337d565cc7e3aced7f5e7935a92d5c7b90f39fd4463d21be062e84b18ea50fb151c591ca0853d7aff5c15faea42eb494d2543e0584b95cc5c5329372cf08ceae83cf525abb2586ff01b37f9408d6e300182f8c332451d1cf7a6e1d3e3dfd449f1c0fd8f4c9e76b8c56af94f2fdde8b05bfc8e0fb87839e5051beea20cd3d18ab90d25ca38b56afdebce9f8fc75c4bd100b933f07615069faaeb701612db85f242f91069b9312ba23848a5e16e1cd3729bc8f0bd7a73f97127f857ff8c66a9f1c3e2b90faef462a7ecd6ed1b921106ac9406aa8ee2f0f0dcfdcf56382e9384d2f3bb515b4589aa1990d7b29d2bf908408ab11659d870c80fad01db2ad801fa2f630b6cb9189e4fc1fe548ffbb95bbe3457158127bd6b4767bbde7563cb53292c57a529cb76dc724323f173ae663388f4f6ce49d63da0d0827879ddd549662b416cadbcd0026aa6d5e7d552de798cb9f8b4131b7cb4bb9f6e91fdbbf27de1693107d0bb573be4938478cb57072825c93c50e26347aed3de206c3a8704d4d4643568e215f9915f3e0ec51128588689246c902eedcd40a554b8931cf4afcd27d54b832d830f0444b0d7138eb288b248ffd7692b19e3b8bb25a5c50c22a570dc668d1e776fc131a74de425457fb5981984b61cb37516136b61dea573266c6e7e80cb10c1f7c5f21cc6b7d5d0f5323e8af42d5137d6839d41854da13dbfbe4eb63af71b60becde2ca226c9a57b3c71bd5f5ff02fca5af7e6a75346a4f1b545930675b4df858127875237ffa9521164426b06702906a14ea7b672f338a1c4d5edebad3fe97682c39f86e0955468dbf1a2d1e0d1f4f388ae929d662effcb5c1e7adca32a0210761edaceb179f88599db4c95637051513839a2e5ed78ac06be3c53010afc2c077550f4639ffab024cea230060d4cc30ab46b0c57e2aaac632b0eecbe0ceccd177dfa63a1c8e0fb3fb6b0c50383973c2e2b35003d4aafa9d7d6c39c9f3019495ce5bddbe33c84df4c3d4625efda9909a0006d49e9c9321233c6175e3e18e9b3263ab35c58cc2baccf58450f5b059fbe5072b3e4626db65cabd7a77b2608d75cc9abe51100a583f053c293fd4d1f849359c39581f2f9f5eeff7eab89008268c65698ee69c4bfa74bb457231f879bd5f6b278826e9da71c8f6fa8cbabfa462e4ea06d7d92371fc504d7808d4b3e9064b3e5f69c845852448eeead6d91e5853bca6ba428f420ad63784653638e92e4472f179e5aea1c1ce28dccd58ad95ca762a55c156c1512c1077046e673dd5207ea94c369082ddaddf9a7f9342d7f972c07809256dca4af09339a4281fc87bfa41bf5f56374c853d6960ee830a2e5426164961dacb35f331785ab3b3ee66272495727671f5acf246ac4b944df821941ead645fa5c23ce86a736ed1d848ffaf56ce1e8963670b525367c825cd2644e3d9d9ebd4734f945f19af472478aedac0776b5f5e91d419637e8db2275be645ade4de5bed679ec8d9cef554c197a5f0102a140e0fad2a4d6dfa30f1974edd6b374497600af3c0d287e667556faaef09f4fa8ef890a9d0fec6219307fb53fe4ee9e3cfea655ec6e456bcb34110d557d6a6ec7f1979b7456d8a67f638d7c73146f04647c77257e2b5d54da497a78065d2cc9f583cb96241dc3803de6c03d735e870b820a76bcc4c428cb6e3aa19b8c60fa87831da6677a9eca105944836001f4e3629fee8b3950784a2bf190d0275c1dc43b330ad5b9c80f636d1f197a3dc4c8df5e506601d3144afce9aedbb4e94243d0ad4ab74ddd56d1f67d0d634fdf15b18bc2044008d7c8c421721627c3715b063fc1bfa3f2b7850a20a6979d8e253ef3ae67488cc550c217212b7b8597f257187747040d49c04bde5b169ee20bc6794f032c865d6f450701884ec2b1f43d670c8eb66476ffe3f815a9368301f5b703e9f60d876fae15521d949bdaea0a6c585f6dac694d1a63be0ad0f307dc4286f891cd4b8c2be03dfb27947148e7c344d4ec838da9e5eb5debd3cab12bc96c7eb1a007d5dc30dbff897ca30bfc9a971503fe9af30f58a4a1ea61fdb8dbaba409e22d37bd7927bc8f673ca69a9db15ec9ee77b218a8d079ad8190f0d003c00e7bc21991408375454b1d27ee41d0903a91d60cc0231ffbff15d51d641ae6b673ea548a1b04de6f1cb84b04f801e136e7bba4fd532f7f2c730e6e6a38d4a49d72ecf6fd09373b0a2070401eb3a07906905040739ce4daf4a711d2d91b79963f1edd0c148720426cb8e915eb188b5da02216f9dc58d51b0be78a903449946d4f03f02f74bf0ced26e176023c971c9e770eba4d5be6952c71bbb7289ac1511e176c1ca0955e34ade0c5305cabddc3091a77852d557922bed1faabcfb5a51e39462b6527c8526f6b310bc7ccd1d416893a4bf10d209cd073563a0cf75415bda9834504061415ba1002d8498b8fcfa80ab190b7a731e5b8c009bfb1e6b05240db190e7204a787daba3ea1c112e89f8fa696a0945bc78ece1cb11f489e4450718b10f961e82add71d987aedb728a5758f4d3001d28af65b683390298365ecac3e2a8425c2eb869756526c0cb0a61921031ed24bd7223d66d6c7c1ab036d96a063a60ee6eb848fd796f8b04bbe130de6ac52aead695afcf790946fb868f900decb0ccbc3c560c9fa97af34a1efd17b2e11983f77ba28a8e226b758d150386d4ce842c7e1e1ee7c7b01fa742c17d94847492f1ec77ac6c0c9be462631c050ea481b2182ad151ae883ef93dcf95b5228033ee3fc30ab6db4f3e3e1d0c990f129cce3362db81c1748a7412630d36272080e8b3c71b1c1d86ead6cd8239d72952cd479c22fe2bf31b35cf9d2b99a5b92747d9f2ab2349d57d1bca2c297dc814fd35a12fee1c0a0833cc59895155c3d213677b1bd6e7df37ab1dab1ebeccbdc41fad0ec269249c074055a36ff3bc3cadedb7e68f82223e6c12cf88aac32a730245d3ee1a180cba6b50bbcc2e0881f1af82123783fa38578da05b17e959624c6acf3949de7fe287a747934c4db67d019d291653493f61eb9f41537dc509f0e080a7c48abdb367065eba7422a9d7875a1e8d5b186ff9518b40c6a28618903e035c84e7a21bf7ce4f4c98d894a13e07768d9384e7fb0ce8702b70d18cf1f7597c444abd0dcc833976d6ae9b2d147229dd81901ac7e1c0eec717f19f552152ce042222793990a9f9a98693d8b78b366b2e6ebaddcf68583544d2df8cbaf4a32d31096a0fca759bab8819648eff34be8ecc8f7c38b142e3c26a9991415387a0f0950917503d3abee2340257e150f6a701dc5bdeb5af6e18bc87d4070a9aee22ee669168d91acc183d8a0634b3d661bf130e6f2e07921a943d428df38ba4b22b964bebb637213a170c60f73de189e4323c26813f2fb2a6dd046bc6d1cca4816a483c131b37f60cddcb9dcd896870ef55fd85cc49e822b81a1bbe799760bd60a4e0a14146557ed02ddaa803743d92123926e07c938e662e288ca7c5025c58fe53192ee3e8d98e5671c85ad61a49f439d4a5040cac9b40a15117d97348a6dedcbed6e9306466088f3e6e17ec5050006acdd2aa1cb5153fe40bd4c27c06b9db39a22f5ca9cecf0cd0a837dfcae8bbb104434491aca915262d4df99ef411ff9299a7d96d95aa6caa6ac5e6e5625a0bc9b70e49abc0d49009200273e6b0e24d2355a16bb4733127113c60e0712c875f10ccadb12477e6668368f92396972154b6102efe45f8969979a961665b3445964993da01ef6ed9d6d848420add9409b56faf4fd158eefe813cd32885292150e97d1cc7e8f335c942c0e924d41749ce2e12eb6d6505736ee596271bef9ce5d1676d30c558621f936aa39c45579670bd9f0f2be9daa3ccdb8793041e637b3a0441e9f7469943f26a3975518e2be414183874c7900c8a404eed5cde09b752327594e2aa57d7de07452f4d114e03e1f599d99e47d24b83f1b99eab943bb649104ec0f3f76862d5b5cff8ebf81e88ac2dc58c405e3a30f0da45ed2666d9dfe7080a145408dc790f061eb0181490b85f064c896f2a079b68938631491d77c156832125dd7471fbd3d11c9e08d47e359fb9bf65b35a5da93c39acbd4299bffb895bb338e14de5cb835d9442bf251bda9815e0048d8507b2ec8960f1dc234de71ea0715a8e27e2d9c0f1a4fc5be167714d791b95e3d778f4e886e495bb2047ef2f0ecb604ee40199c2f70b566e9dea6c796de3b82e3dfd29056f98a19eee919f97e08841e1633deac7024a522cee4e9a7ffac9d57016c570f7e2834205806420c0be764613befbfd7aaa93c0956540190233d1ba29d0b9b67318cf600a9b9fb6496d66c3bd92cc7e4ad47f62cdada3086189ea89cde8d9407ef914e4d9dde73dcead7415a1adba6ce0d5bfab725b5d8268144ce10064b79085c9ced4787a9eca9077a95a61c87b737517f6ddfe7577aad9e8611b61de7e1385ebc6361b31697f7b947dadc6f3ea0c49b654d95467a5ae882b6326dd96085f9459eaf49df7244b2a0a98d5e9249738c03585b63dd23d80972ce71570c5d33316afb4603e63cf637d0d5270b561de473be51d3889a4235fcdd147c7bd9b50785abd68402ad1ca09104748a81dff5d4b3e7d1b37592226a017160736f84e126197e53f10c9b186560195b4d4fdfe5856a1586dbdae65b5b2693934f6474e9e38fa38e3aea8804456cb75c414fee3c6b6a9995fceebaddede2d0db905eeadeddd73cead19ed81cf593c7096bc8dd470152f0a340e3caa7f723e0fda6d3187375e0043ad5943fd89cf5c7a907c76ead16345d800fc44bff90a4d7d88faf59c0b837a85bc9178759b35de047a32972d4b0d295372c8690aafcaba80c829b1b5b68b6d66070e2fe3950724014ecb43a529f1ac528524427323204acfde584047bc94e3357bfb0294f29f154ea2b7ebf2ee788d47034aa9a12bce35ca3256c2b064735836df47ac07fcc53225ea29f1511d33bb2286a25015990e9ec67d019048b3d6e09b578b5e2765a1b53951c3469900d23837123840a132a255910bae32949f27e606d31cb7d283c137469fab54c473d1bb68a8f04f0ef86591807590ec5f29211fcddad07ba0a09505efcac01acbb58205d475f83b3fc24218699f0ae29786d6f13e0f93313e3002174e73f42918d02be000e93b054b824cf2c747fb96238d47ee6ad94ccdc1b12322451c6fd2b802b482ebc389d458e7858500eb4720496ac0c8c7c6e2c922c987a57fe16bffe10dfb39f54f462f7b17efc387b53a443493b39cd6196b0d0160c50c21d6d2086dbd9d4c281f4336e277945dcc3ef622c4be1a6e8295ab4214b37803c4cce1f094f5730729e46825c00ffcc55012882678c43f81e7ae8999781e3866a983147dcaf5fd43f2069bf25f5175af603b9d153aff7b35143167117dc93b20d55f5271b953317e76b7ca2464ada3cdd37ba99f48e983b57f9058cf3c27fc22870a8828afdeba2ce104f742db1df1a2f00ff8d66351bc29af4e750b3c014ea82c9f9d421e49e67987896d4367719d7546a58b30b38e8262cfe397f88be6bdf0bf9953adb8a718b48e595041f67c3fb45f8b1f0f364010c4bc048ff543f0e1a661ab6c0fd938ac516583e461a1290c36e9ff1c2852ce39e408619be22dbfc6c463092a8413a1944564002cf6d18cdf06c5c83fad199c6c49141042a6a654f7cdf38d22ce2264326825da1c13656c2ec19904bd3197e5de9f7961cc65c8ee4cf9d693e97abdd9424952b622e6a1df619529675480264c37b2fa0ce9545f81eab023ca72d88ad2fd900449b81632e7349c24a45b9731028629a8b7552c74ed35040dfb470d6cffec705a962a1d482910769ad1f98f92a17e14e2bb1d9b8b842dedfe2b3ad40e09429afea494189d43cec7168aa4e2f0d09071f6555d89b852eed84252e8a7e0dcf6a141c78724202b7ba49b9ccd2714c99d290ca41e26acbca4ab9f34d9261479849092a52f225fb669effff6d9578bfaac1eee7d35a2a51962f975a149eeec3ec607be388a194a7335df8b7c2277069400d6d52938e9bc87a132496ac59f7046dc17cb315fa159348863a00fe217d3446741d49e27aa4e7f554b28d14a32efb01ad39d68fee4d50b08913415fcec5c6a7d4d55342f83547bdece1a8039898cbf0a2ed0fa068f305b171d281435d5142b0346de32a4bdbbda840099dfb309c672567c9077796c0f187cff88cfae391e5623d3eacf926ba0cfffd4f0b8853694e31ba1d4222ee8de5d95c0b30ba6109a51d6277f2320aa8f0fe51d5d846520681f8ba7d72e59358a175b7ca06d780c6da6c1bc45770207934ba1bdd6a418997736b026235178c720f29d337d07938e7cb1b228807adcbf9850bff6ecaf296c195c88e6be7dd92fda9fc9f70b51b13088b4315ee2cb7606df242453b675bc13abe07e2865e420a22b26d752c75fa89d4d3933797aab16c7f57b8fe724699135942e3789de2040ea4413c69e4720eaa4742e2dcffc006a39d2cf32e16cf84bff9d8b6db0d3472d860ae3a5d6f0db9e580df15031cbbbcf2e7cdc292e3f03032c8bea6ce74a2934ebf5ee7fc871f1f36f59aa3b0fa5da71354f7b5c179dfad0e98fc0ab1bd19a3c40b47e511e2f7940675c480f112bab8b4b000667396bd44b476384a1b725b498a8486137ea41b2de7671544bf498a7a8dae0226fa5b38c46be1b9521f8f5483a55419f8c456b07fc45989064c5f0a9bb4f687fd71a8a8b30796e2bac5e900acfb6f1f94e9b5952ffaad0019648941d2249dbd947188ea481ebad7dec1e7afe9a7d94e72ac302184c18b17db767e3b33db13d0cff9e534db8ca5d581db06f05ef6ae501208288be6d7483fb71569651e1940efe386a496b1c506ebbc7ca5972d1f62048d31f38bfaf82c3d50d85c277063c23f905e043153530c4ae326a73108775d0e8a10fd848dc404b9d6ad6c73a3a5c9db20d22553768cf2d8f98d1dc5cc68a30fd89c4c32f86b6425edb35c0ea19a95931468099ff1d14235b02d9a74cf0b829c52d2fa608b5e14b6dbc970684699941be6e43c15c2c536606dfab36f27af3e8a35bb91d3895bb4ce95057377e0becc3c76c2d2b14c2057f69e342b37961758c84ed690abbe20edf55efd8b2d5e0059929610f62196c515b04a09bffc44ac559546d20413f80a0418b6da789c430acf8a3e7695c002d1c792d7b09758b0bc95316f0b8f7543e2bc40fa2f75dbf799691514e2460175ca725b6e8f1c9e4fdb35d7e42faabd0624c9411f64e117c5f0b1bd7d4a2d7da0d447b92a125045a698a3881ac36b01927cc232b14d26896e2f2f84c54593a6b244a2f4434eae9a456a92b527ccf40a9016b9f494a8113989f79f4e73d8528b2512c8293ab617d71f0297734f62b9e504ed42821283b7359f71c3ca5cd65faf31471503d320c6a7c9efda450d2acfe0aa0a77258b7080958416d18997d75cd76fff1625c902ec6b29e0a6e8a76e59d1ef31a15b61d808325bbd709b59b8278737fd48f617ead92ba767c887cbcbac4075913d4e40862b056dedcbbbbe1be754364a3fccf1bd6c8727ef4a009f5cac22df9cf81b042fa7ba07177e02ecd75a1637957a5f92902bff569e3648b21077d29ff07b16f6e826c2f779fbd8877e1c01078c66e83b78b69d1a4ed0467b5d49a7155e4243d210a176051b4e86084eea7688d52b318b9299e16df4e8fb6c44935e9996b447e1d41e1cf43848f375266f5045e6dab132428da513a0b08d54736225f361d80458507ef948293b6ff89412eefd61e84a98cf0111ba711923bb47737127398d3fe9815201b33ca523f5f3d8804c31e07d73b04f292abcc3fcb5db43aa7d4c500890f113bf6d8acec630068a348bbcfe8f39921b121c7091cd46bcf2c5a598f3a750a1f1d564b5d62c4ed774cdf32d3bc89f7561bc3951555976726867edf42383545e2d74f63a06bda93a202d7cdf7f78cc83c77b31c39e7935fae8b051f9a9e4ba7c8df54e577606aa24f48d1a91852fde7bdc07f97c9555a625a1f43869038e7c595e8a4be26897a1e7321cf8abee987599e249895505f156a75173aed9b3687d235bc659aa3ae103d54948f5aa092f841d361633802291fbcca537f94dcf357aa7a4600841ecb31c5d6d212a505b7ec0bd33bfd3a8ac0c1a8fb17418fc3d47129ea065937f8ef22a8180855dc49992aa859770635eb54ffa49790168b7bc93f2f91b102af3d371e61610abeb40272010bbed30bdc34d3d4a1dc7da7173a78164827606f940ef25074e57267e2ebe7ed47882272f89f342d1408d1d134e1d620384cc3c9eae9a907c2685624910b1b3cc84409beb1271f6f62dc4ce9a072081fb54d907c52b058b5728cf550fcb58496a962e7bff84e779a3e8cf8ba2557a6fc2bcb2610689908445b97364308d005bd144929d324cd5de37e0236279df9d5be0eaa6f1a4d9a0449b84c7a26012e655635212ad119fd1b4d3dbece32e218c6c336ee219f9bea9c28dad8b5afd9ef2af924108eb3d96f570ff54b8bb8edbf837c6121e15ef8ec49b64be944c4052a98eb1d8a65640f0e416eba0878c9943ae99065296ea7706fb15570d20d6cb336b641434b69a9d76752c8c18c0c97c08bb82ad21fb7d6cdd795352055875a517425971b987d706a58e2bfaee66d0fc155aa32342f94229be7329dc938d0ac3b55b0099d12198a96aa3e530336235b89f418c6cfc27268f57676d869a3c6f55a5f7ee3e529e414377cbee59381b6becd3beb9f0097201cb4460bdc28cfbcc9dc9a930c52a586b88b676876a116e9f06dbc05a4828954bfc5159017d4e2a612fd2d75b4b77d2a3c95544a355b221c3d0cd03c1e14d0bb241562a917d32183b07781915c43fa8ba8af1dde867dc1177a8509270e4e0f5852f77e311629e545315e3c26891af167f3574bf2333e4607f0028ffef71644910fe3e6a3b67f49f709b7a4dfc3f7f5b191d804ae702f5ad804070506e4490c9f8040ab30bc6be31c27335ae2247b56982aa43ea852d4efe6bdcb3cb7aac45f5f05affd248e27ead9547f9900e2b5265e46109f0f8b1db8fe879fda502cbe3724417803fbf00ee4f6fbae76e5b0ec770534c6886800ee961002c30e40657a9dda48d91f11591debc580e32a778b37e987d3bbf9a71aeea7bd9017a6a71aa0206dcf05816ce017642e993c00817fc2ca9e15c7d5e3cace96b76267232633c2913063b953875391712d19fff30d963a6a12f9b824617a30380c11ad00bfa864de0ab1cd4e4345c51bdc871c69ce9d448cbd11ebbcbbccfc3c3dc703236e722065a67b248292300842476a57658da437409037114f36c1f554331e984422b2109dd1004e1b44f7194858a1e0d0ee00b6d7712d45e8549768332595516bf22611315197dc3c0996dd455043bf98a1a58b6cfdda5dcce76d211fe88d8d03ad64ae44e3491e46c1832409c95a5205b07af2905b525b088cb7a6c539752bd21bbb07ddfcfa8aec4e1eed5a97e6a33d8145b700c088c62ac5766ba4b0e9b94700ac65fa85f3c2fc5eae910c68add9d96bf3af8315af7baa453f722fa8c7fdd7f838668de3abb8de2adcf00b634e821cb996c1eddaa59edf3bf4e780c9be7f2ba04a0ce5e30250b440763f40da10b2c6d0ebb511b591fd3a884bb8e32102af63d91e9d28750566030570ff5e9a175fa3c3d2cd8a4f09f9ec392315f971c7479eddd81f282cb4dbc23ee0ffdbf9650878e3074d9e783157ec983fe368a53a9f32abb987751adbff18923fd40ffadbe204884d083c058f9da8a36c5469acbeb36515ee1560704745ea18e7e669a5e63c1c0cb7ecc1f5f048d24cc45796699c0e2d475472d6c4bcb76498c5eb06206cafb08758f12500d02aad13d07f1a4e1a7036448194bf1214868c8ce6e62ab5091e22854261e13175151781a38eadcc55d230bcf7765f6ddea9b4b7283b9bf1855ba93d850650fb9ad19a7265bd19bb4c415de7c2a330e2929db6bc9be0c18086aa7a74f985b5532b594c57d6d56bc6134a5688f08338a7683a769cea9dc23dc2d32a8d25f28dcd746dbdae13f35dd13bbe806463a3bc6390ba6f00f8f0eea293a6f1e2576ba643edf166c43e955ecfb69123ca8e349cb90a1b577b06f65ee7b1e9e5666e647972d2963851ed935ebfd4a760a041fddddae0a192e3296a8d05574486faedfed9005672c91d7a1e7e21e02151afacbd456a5e131f20f7b654ac4ea34acfa3ec5fed586025e2604340daed09d8fbff27d0b6a6aba9bd6a2d41a9367c15e933f031a455c9d5f422a0ab63c9b54a7ad218eb27b4b71994b0ab1a6d9e7bc4d5534613e4212996c2891a60e8856c7b24d0f35025d5fdf3174de7296bf16dd267f87d7f4186e2606383a91ee66534099f1f31508e14c680ed47e6ca7f4ec151a5119db30f6f8cfdff8f3547b0597c31e20f1c0cbcfb7337e0ae0fe9a2035e8875a4fc4b6aa25a3279db4d10f43003d3d8e813301e4b0f5f04f9e0a193063b5604bd59c3972feff6712e5916e06aedca46e95fb123759c8c81a5ce49db16a1810f7373b9f5372af421400145a98ca3b733fb74d31d754a3faa1a6cf9f82a049b8080d0448e5961cee33a541f605517b7ba38f2658443d4d8460996b3605aa986e6e586cd3627c81f7fcee3ca268aa1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode | 54. 螺旋矩阵 II</title>
      <link href="/2025/02/24/leetcode/54.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2025/02/24/leetcode/54.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-54- 螺旋矩阵"><a href="#LeetCode-54- 螺旋矩阵" class="headerlink" title="LeetCode | 54. 螺旋矩阵"></a>LeetCode | 54. 螺旋矩阵 </h1><h2 id="题目"><a href="# 题目" class="headerlink" title="题目"></a> 题目 </h2><p><a href="https://leetcode.cn/problems/spiral-matrix/description/"> 力扣题目链接</a></p><p>给定一个包含  <em>m</em> x <em>n</em>  个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><p><strong>示例  1:</strong></p><pre><strong>输入:</strong>[[ 1, 2, 3], [4, 5, 6], [7, 8, 9]]<strong>输出:</strong> [1,2,3,6,9,8,7,4,5]</pre><p><strong>示例  2:</strong></p><pre><strong>输入:</strong>[[1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]<strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]</pre><h2 id="思路"><a href="# 思路" class="headerlink" title="思路"></a>思路 </h2><p> 紧接着 <a href="https://leetcode.cn/problems/spiral-matrix/description/"> 螺旋矩阵 II</a>的问题。模拟思路和 n 阶方阵是一样的，即使变为了 m 行 n 列矩阵，仍然是 <strong> 右下左上 </strong> 的规律，具体用了上题的官方思路。</p><h2 id="问题"><a href="# 问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>第一次提交错误</p><p>  方向左和上的时候，循环判断为<code>for(;j &gt; offset; j--)</code>, 事实上应为<code>;j &gt; offset - 1; j--</code></p></li></ul><h2 id="AC 代码"><a href="#AC 代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; output;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(); </span><br><span class="line">        <span class="type">int</span> startX = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> startY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">min</span>(m, n);</span><br><span class="line">        <span class="type">int</span> loop = <span class="built_in">min</span>(m, n) / <span class="number">2</span>;   <span class="comment">// 循环次数</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 定义边界应去掉 offset 个输出变量，每次循环此值加 1</span></span><br><span class="line">        <span class="keyword">while</span>(loop--)</span><br><span class="line">        &#123;</span><br><span class="line">            i = startX;</span><br><span class="line">            j = startY;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; n - offset; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i &lt; m - offset; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j &gt; offset - <span class="number">1</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(matrix[i][j]);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i &gt; offset - <span class="number">1</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(matrix[i][j]);    </span><br><span class="line">            &#125;</span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = startX;</span><br><span class="line">            j = startY;</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;j &lt; n - offset + <span class="number">1</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    output.<span class="built_in">push_back</span>(matrix[i][j]);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;i &lt; m - offset + <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    output.<span class="built_in">push_back</span>(matrix[i][j]);   </span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode | 59. 螺旋矩阵 II</title>
      <link href="/2025/02/19/leetcode/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
      <url>/2025/02/19/leetcode/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-59- 螺旋矩阵 II"><a href="#LeetCode-59- 螺旋矩阵 II" class="headerlink" title="LeetCode | 59. 螺旋矩阵 II"></a>LeetCode | 59. 螺旋矩阵 II</h1><h2 id="题目"><a href="# 题目" class="headerlink" title="题目"></a>题目 </h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/"> 力扣题目链接</a></p><p>给定一个正整数  <em>n</em>，生成一个包含 1 到  <em>n</em><sup>2</sup>  所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> 3<strong>输出:</strong>[[ 1, 2, 3], [8, 9, 4], [7, 6, 5]]</pre><h2 id="思路"><a href="# 思路" class="headerlink" title="思路"></a>思路 </h2><p> 首先思考螺旋规律。取 n&#x3D;1~5 尝试初步发现以下规律：</p><ul><li>第一次一定向右填 n 个数。</li><li>随后一定是按“下左”“上右”的顺序填数字。n&#x3D;2 时，只有一次下左，没有上右。</li><li>每进行一次“下左”&#x2F;“上右”，下次进行“上右”&#x2F;“下左”要填的数都比上一轮少 1</li><li>根据四种填数方向改变 i,j 值</li></ul><h2 id="问题"><a href="# 问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>vector 二维数组的操作</p><p>  初始化一个 vector 二维数组如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">table</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>))  <span class="comment">// 定义了 m 个一维 vector 数组，每个数组长度为 n，初始化为 0</span></span><br><span class="line"><span class="type">int</span> row = table.<span class="built_in">size</span>();      <span class="comment">// 获取行数</span></span><br><span class="line"><span class="type">int</span> column = table[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">// 获取列数</span></span><br></pre></td></tr></table></figure><p>  这样等效于定义了一个 m 行 n 列的数组。</p></li><li><p>第一次提交错误</p><p>  for 循环中需更换的变量错误。之前用当前 i,j 值作为循环变量并≤n，当螺旋越来越“向内部”时，此时 i,j 非零，可能 i,j 在循环开始已经超过 n（n 是递减的会越来越小）</p></li><li><p>另一种思路</p><p>  题解的思路是，每个循环都进行一次右下左上的操作，考虑边界时，注意每次少填一个数，例如 n&#x3D;3 时，每条边就一次填 2 个数。最后在考虑 n 为奇数时填中间数。</p></li></ul><h2 id="AC 代码"><a href="#AC 代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> dir = <span class="number">0</span>;  <span class="comment">// 输入元素方向，下左对应 0, 上右对应 1</span></span><br><span class="line">        <span class="type">int</span> currentI = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> currentJ = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">output</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(currentJ = <span class="number">0</span>; currentJ &lt; n; currentJ++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[<span class="number">0</span>][currentJ] = value++; </span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">        currentJ --;</span><br><span class="line">        currentI ++;</span><br><span class="line">        <span class="keyword">for</span> (;n &gt; <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dir)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 dir 为 0，则为下左，否则为上右</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    output[currentI++][currentJ] = value++;</span><br><span class="line">                &#125;</span><br><span class="line">                currentI--;</span><br><span class="line">                currentJ--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    output[currentI][currentJ--] = value++;</span><br><span class="line">                &#125;</span><br><span class="line">                currentJ++;</span><br><span class="line">                currentI--;</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    output[currentI--][currentJ] = value++;</span><br><span class="line">                &#125;</span><br><span class="line">                currentI++;</span><br><span class="line">                currentJ++;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    output[currentI][currentJ++] = value++;</span><br><span class="line">                &#125;</span><br><span class="line">                currentJ--;</span><br><span class="line">                currentI++;</span><br><span class="line">                dir = <span class="number">0</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode | 904. 水果成篮</title>
      <link href="/2025/02/14/leetcode/904.%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"/>
      <url>/2025/02/14/leetcode/904.%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-904- 水果成篮"><a href="#LeetCode-904- 水果成篮" class="headerlink" title="LeetCode | 904. 水果成篮"></a>LeetCode | 904. 水果成篮 </h1><h2 id="题目"><a href="# 题目" class="headerlink" title="题目"></a> 题目 </h2><p><a href="https://leetcode.cn/problems/fruit-into-baskets/"> 力扣题目链接</a></p><p>在一排树中，第 <code>i</code> 棵树产生  <code>tree[i]</code> 型的水果。<br>你可以 <strong> 从你选择的任何树开始</strong>，然后重复执行以下步骤：</p><ol><li>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li><li>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</li></ol><p>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p><p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p><p>用这个程序你能收集的水果树的最大总量是多少？</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>[1,2,1]<strong>输出：</strong>3<strong>解释：</strong>我们可以收集 [1,2,1]。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>[0,1,2,2]<strong>输出：</strong>3<strong>解释：</strong>我们可以收集 [1,2,2]如果我们从第一棵树开始，我们将只能收集到 [0, 1]。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>[1,2,3,2,2]<strong>输出：</strong>4<strong>解释：</strong>我们可以收集 [2,3,2,2]如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>[3,3,3,1,2,1,1,2,3,3,4]<strong>输出：</strong>5<strong>解释：</strong>我们可以收集 [1,2,1,1,2]如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。</pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tree.length &lt;= 40000</code></li><li><code>0 &lt;= tree[i] &lt; tree.length</code></li></ul><h2 id="思路"><a href="# 思路" class="headerlink" title="思路"></a>思路 </h2><p> 题目的本质是：找到最长的一个子数组，此子数组的元素种类≤2。</p><p>基于 <strong> 双指针 </strong> 的思想实现。定义快慢两个指针，再定义两个 int 变量 <code>fruit_first</code> 和<code>fruit_second</code>分别存放当前子数组的两类水果，初始化为 -1 代表还没摘水果。再定义两个 <code>output_first</code> 和<code>output_second</code>存放输出数组长度。</p><p>然后让判断每个快指针对应值是否等于当前存放的两类水果，如果有，说明当前子数组种类仍然≤2，令 <code>output_first</code> 加 1。</p><p>一旦快指针发现第三种水果，此时将当前子数组长度存到 <code>output_second</code> 中，修改当前存放的两种水果类型为 fast 指针和 fast-1 指针的水果。（此时 fast 指针和 fast-1 指针一定是两种水果）并令 slow 指针指向 fast-1。重新令 <code>output_first = 1</code>，令 slow 指针向左移动，直到出现不同种类的水果为止之前都令<code>output_first</code> 自增。</p><p>如此一来，发现第三种水果并经过如上处理后，在快指针重新向右移动前，就可以得到新的子数组的当前长度。</p><h2 id="AC 代码"><a href="#AC 代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> output_first = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> output_second = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> point_slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> point_fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fruit_first = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> fruit_second = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;point_fast &lt; fruits.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fruit_first == <span class="number">-1</span> || fruits[point_fast] == fruit_first)</span><br><span class="line">            &#123;</span><br><span class="line">                fruit_first = fruits[point_slow];</span><br><span class="line">                output_first = output_first + <span class="number">1</span>;</span><br><span class="line">                point_fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fruit_second == <span class="number">-1</span> || fruits[point_fast] == fruit_second)</span><br><span class="line">            &#123;</span><br><span class="line">                fruit_second = fruits[point_fast++];</span><br><span class="line">                output_first = output_first + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                    fruit_first = fruits[point_fast - <span class="number">1</span>];</span><br><span class="line">                    fruit_second = fruits[point_fast];</span><br><span class="line">                    output_second = <span class="built_in">max</span>(output_first,output_second);</span><br><span class="line"></span><br><span class="line">                    point_slow = point_fast - <span class="number">1</span>;</span><br><span class="line">                    output_first = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">do</span>&#123;</span><br><span class="line">                        output_first = output_first + <span class="number">1</span>;</span><br><span class="line">                        point_slow--;</span><br><span class="line">                    &#125;<span class="keyword">while</span>(fruits[point_slow] == fruit_first);</span><br><span class="line">                    point_fast++;</span><br><span class="line">                    point_slow++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(output_first,output_second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/01/03/jourial_24_01/"/>
      <url>/2025/01/03/jourial_24_01/</url>
      
        <content type="html"><![CDATA[<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>A test.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计网基础</title>
      <link href="/2024/10/21/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/21/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章 - 计网体系结构"><a href="# 第一章 - 计网体系结构" class="headerlink" title="第一章 计网体系结构"></a>第一章 计网体系结构 </h1><h2 id="1-1- 概念 - 功能"><a href="#1-1- 概念 - 功能" class="headerlink" title="1.1 概念 &amp; 功能"></a>1.1 概念 &amp; 功能</h2><h3 id="1-1-1- 计算机网络的概念"><a href="#1-1-1- 计算机网络的概念" class="headerlink" title="1.1.1 计算机网络的概念"></a>1.1.1 计算机网络的概念</h3><p> 计算机网络：是一个将分散的、具有独立功能的 <font color=red> 计算机系统 </font>，通过<font color=red> 通信设备 </font> 和<font color=red>线路 </font> 连接起来，由功能完善的 <font color=red> 软件 </font> 实现 <font color=green> 资源共享 </font> 和<font color=green>信息传递 </font> 的系统。</p><ul><li>计算机网络是 <strong> 互联 </strong> 的，<strong>自治 </strong> 的计算机集合。</li></ul><h3 id="1-1-2- 计算机网络的功能"><a href="#1-1-2- 计算机网络的功能" class="headerlink" title="1.1.2 计算机网络的功能"></a>1.1.2 计算机网络的功能</h3><ol><li><strong>资源通信</strong></li><li><strong>资源共享 </strong>  （可共享<strong> 硬件，软件，数据</strong>）</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li></ol><h3 id="1-1-3- 计算机网络的发展"><a href="#1-1-3- 计算机网络的发展" class="headerlink" title="1.1.3 计算机网络的发展"></a>1.1.3 计算机网络的发展 </h3><p> 第一阶段：ARPAnet 阿帕网→internet 互联网→Internet 因特网</p><ul><li>因特网是世界上最大的互联网。</li></ul><p>第二阶段——三级结构：NSFNET</p><p>第三阶段——多层次 ISP 结构</p><blockquote><p>ISP：因特网服务提供者</p></blockquote><h2 id="1-2 组成 - 分类"><a href="#1-2 组成 - 分类" class="headerlink" title="1.2 组成 &amp; 分类"></a>1.2 组成 &amp; 分类</h2><h3 id="1-2-1 计算机网络的组成"><a href="#1-2-1 计算机网络的组成" class="headerlink" title="1.2.1 计算机网络的组成"></a>1.2.1 计算机网络的组成</h3><ol><li><strong>组成部分</strong> 硬件、软件、协议</li><li><strong><font color=red>工作方式</font></strong><ul><li>边缘部分<ul><li>C&#x2F;S 方式</li><li>P2P 方式</li></ul></li><li>核心部分 <font size=2>为边缘提供服务</font></li></ul></li><li><strong><font color=red>功能组成</font></strong><ul><li>通信子网——实现数据通信（下三层）</li><li>资源子网——实现数据共享（上三层）</li></ul></li></ol><table><thead><tr><th>分层</th><th>备注</th></tr></thead><tbody><tr><td>应用层</td><td></td></tr><tr><td>表示层</td><td></td></tr><tr><td>会话层</td><td></td></tr><tr><td>传输层</td><td></td></tr><tr><td>网络层</td><td>路由器</td></tr><tr><td>数据链路层</td><td>交换机、网桥</td></tr><tr><td>物理层</td><td>集线器、中继器</td></tr></tbody></table><h3 id="1-2-2- 计算机网络的分类"><a href="#1-2-2- 计算机网络的分类" class="headerlink" title="1.2.2 计算机网络的分类"></a>1.2.2 计算机网络的分类</h3><ol><li>按分布范围分<ul><li>广域网 WAN<font color=red><font size=2>交换技术</font></font></li><li>城域网 MAN</li><li>局域网 LAN<font color=red><font size=2>广播技术</font></font></li><li>个人区域网 PAN</li></ul></li><li>按使用者分<ul><li>公用网</li><li>专用网</li></ul></li><li>按交换技术分<font size=2> 电路交换 报文交换 分组交换</font></li><li>按拓扑结构分<font size=2> 总线型 星型 环型 网状型</font></li><li>按传输技术分<ul><li>广播式网络<font size=2> 共享公共通信信道</font></li><li>点对点网络 <font size=2> 使用 <strong> 分组存储转发 </strong> 和<strong>路由选择 </strong> 机制</font></li></ul></li></ol><h2 id="1-3- 性能指标"><a href="#1-3- 性能指标" class="headerlink" title="1.3 性能指标"></a>1.3 性能指标</h2><h3 id="1-3-1- 速率"><a href="#1-3-1- 速率" class="headerlink" title="1.3.1 速率"></a>1.3.1 速率</h3><ul><li>即数据率 &#x2F; 数据传输率 &#x2F; 比特率。</li><li>单位 b&#x2F;s,kb&#x2F;s,Mb&#x2F;s······和存储容量不同，存储容量单位 KB,MB······ 1Byte(字节)&#x3D;8bit(比特)</li><li>1kb&#x2F;s&#x3D;10<sup>3</sup>b&#x2F;s  而 1KB&#x3D;2<SUP>10</SUP>B&#x3D;1024B&#x3D;1024*8b</li></ul><h3 id="1-3-2- 带宽"><a href="#1-3-2- 带宽" class="headerlink" title="1.3.2 带宽"></a>1.3.2 带宽 </h3><p> 用来表示网络的通信线路传送数据的能力。“<strong>最高数据率</strong>” b&#x2F;s</p><h3 id="1-3-3- 吞吐量"><a href="#1-3-3- 吞吐量" class="headerlink" title="1.3.3 吞吐量"></a>1.3.3 吞吐量 </h3><p><strong> 单位时间 </strong> 内通过 <strong> 某个网络（信道、接口</strong>）的数据量。b&#x2F;s</p><ul><li>受带宽、网络额定速率的限制。</li></ul><h3 id="1-3-4- 时延（延迟、迟延）"><a href="#1-3-4- 时延（延迟、迟延）" class="headerlink" title="1.3.4 时延（延迟、迟延）"></a>1.3.4 时延（延迟、迟延）</h3><p>数据从网络一端传送到另一端的时间。单位 s</p><ul><li>发送时延→传播时延→排队时延→处理时延</li><li>发送时延 &#x3D; 数据长度 &#x2F; 信道带宽（发送速率）；传播时延 &#x3D; 信道长度 &#x2F; 电磁波在信道上的传播速率</li></ul><h3 id="1-3-5- 时延带宽积"><a href="#1-3-5- 时延带宽积" class="headerlink" title="1.3.5 时延带宽积"></a>1.3.5 时延带宽积 </h3><p> 时延带宽积＝传播时延×带宽</p><p>bit&emsp;&emsp;&emsp;&emsp;&emsp;s&emsp;&emsp;&emsp;&emsp;b&#x2F;s</p><ul><li>即某段链路现在有多少比特。（<strong>容量</strong>）</li></ul><h3 id="1-3-6- 往返时延 RTT"><a href="#1-3-6- 往返时延 RTT" class="headerlink" title="1.3.6 往返时延 RTT"></a>1.3.6 往返时延 RTT</h3><p>从发送方发送数据开始，到发送方收到接收方的确认总共经历的时延。包括：</p><ul><li>往返传播时延 &#x3D; 传播时延×2</li><li>末端处理时间</li></ul><h3 id="1-3-7- 利用率"><a href="#1-3-7- 利用率" class="headerlink" title="1.3.7 利用率"></a>1.3.7 利用率</h3><ul><li>信道利用率——有数据通过时间 &#x2F; 数据通过时间</li><li>网络利用率——信道利用率加权平均值</li><li>利用率 U⬆→时延急剧增大</li></ul><h2 id="1-4- 分层结构"><a href="#1-4- 分层结构" class="headerlink" title="1.4 分层结构"></a>1.4 分层结构</h2><h3 id="1-4-1- 协议、接口、服务"><a href="#1-4-1- 协议、接口、服务" class="headerlink" title="1.4.1 协议、接口、服务"></a>1.4.1 协议、接口、服务</h3><ol><li>实体<ul><li>n 层实体——第 n 层中的活动元素</li><li>对等实体——同一层的实体</li></ul></li><li>协议——为 <strong> 对等实体 </strong> 数据交换建立的规则、标准或约定<ul><li>语法</li><li>语义</li><li>同步</li></ul></li><li>接口（访问服务点 SAP）——上层使用下层服务的入口</li><li>服务——下层为相邻上层提供的功能调用。（垂直）</li></ol><p> <img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/cdb01baf6ee019a6acbf8ff48abf415cbbce4c25fd6c71a5448ba7b66934edf7.png" alt="图 1"></p><p>分层结构包含——<strong>7 层</strong>OSI 参考模型（法定标准）、<strong>4 层</strong>TCP&#x2F;IP 参考模型（事实标准）</p><h3 id="1-4-2-OSI 参考模型"><a href="#1-4-2-OSI 参考模型" class="headerlink" title="1.4.2 OSI 参考模型"></a>1.4.2 OSI 参考模型</h3><blockquote><p>为了支持异构 <font color=red> 网络系统 </font> 的互联互通。</p></blockquote><h3 id="1-4-3-ISO-OSI 参考模型解释通信过程"><a href="#1-4-3-ISO-OSI 参考模型解释通信过程" class="headerlink" title="1.4.3 ISO&#x2F;OSI 参考模型解释通信过程"></a>1.4.3 ISO&#x2F;OSI 参考模型解释通信过程</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/33a47b539b6dc2be3879a5fea7901cf795a1d9c75e46f3f5c73a0a99965f7ee5.png" alt="图 2">  </p><p><img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/cf6fdc6ea8f5e9ccba0527892825df0997e8e8fcb414af9273753655996ff13b.png" alt="图 3">  </p><h3 id="1-4-4- 各层简介"><a href="#1-4-4- 各层简介" class="headerlink" title="1.4.4 各层简介"></a>1.4.4 各层简介</h3><ol><li>应用层——所有能和用户交互产生网络流量的程序</li><li>用于处理两个通信系统中交换信息的表示方式<ul><li>数据格式交换（翻译官）</li><li>数据加密解密</li><li>数据压缩和恢复</li></ul></li><li>会话层——向用户进程提供 <strong> 建立连接 </strong> 并在连接上 <strong> 有序 </strong> 地<strong>传输 </strong> 数据。</li><li>传输层——负责主机中 <strong> 两个进程 </strong> 的通信，即 <strong> 端到端 </strong> 通信。</li><li>网络层——把 <strong> 分组 </strong> 从源端传到目的端，为分组交换网上的不同主机提供通信服务。单位 <strong> 数据报</strong>。</li><li>数据链路层——把网络层传下来的数据报 <strong> 组装成帧 </strong>。单位<strong> 帧</strong>。</li><li>物理层——在物理媒体上实现比特流的 <strong> 透明传输 </strong>。单位<strong> 比特</strong>。</li></ol><h3 id="1-4-5-TCP-IP 模型 -5 层参考模型"><a href="#1-4-5-TCP-IP 模型 -5 层参考模型" class="headerlink" title="1.4.5 TCP&#x2F;IP 模型 &amp;5 层参考模型"></a>1.4.5 TCP&#x2F;IP 模型 &amp;5 层参考模型</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/51248ac10db8175939f50280bba99ff0f3886eee1a1fe264a6927963f3545b6b.png" alt="图 4">  </p><p><img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/8db1c2ac5d38b8757443273867c143d0496d7286f8f10dd7ed972dae44c88bd7.png" alt="图 5">  </p><p><img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/668c098fbf9dedc275ca9b670cb8fb588dd8dc0ec72c8d4da159b21d0d8ee3ce.png" alt="图 6">  </p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h1 id="第二章 - 物理层"><a href="# 第二章 - 物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层 </h1><h2 id="2-1- 基本概念"><a href="#2-1- 基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><p> 物理层解决如何在连接各种计算机的传输媒体上 <strong> 传输数据比特流</strong>，而非具体的传输媒体。</p><p>主要任务：确定与传输媒体 <strong> 接口 </strong> 有关的一些特性。——&gt;<font color=purple>定义标准</font></p><ol><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>规程特性</li></ol><h2 id="2-2 数据通信基础知识"><a href="#2-2 数据通信基础知识" class="headerlink" title="2.2 数据通信基础知识"></a>2.2 数据通信基础知识 </h2><p> 源系统——传输系统——目的系统</p><h3 id="2-2-1 数据通信相关术语"><a href="#2-2-1 数据通信相关术语" class="headerlink" title="2.2.1 数据通信相关术语"></a>2.2.1 数据通信相关术语</h3><ul><li>数据——传送信息的实体</li><li>信号——数据传输过程中的 <strong> 存在形式</strong><ul><li>数字信号 &#x2F; 离散信号</li><li>模拟信号 &#x2F; 连续信号</li></ul></li><li>信源——产生、发送数据的源头</li><li>信宿——接收数据的重点</li><li>信道——信号的传输媒介<ul><li>按传输信号分：模拟信道、数字信道</li><li>按传输介质分：无线信道、有线信道</li></ul></li></ul><h3 id="2-2-2 三种通信方式"><a href="#2-2-2 三种通信方式" class="headerlink" title="2.2.2 三种通信方式"></a>2.2.2 三种通信方式</h3><ol><li>单工通信——1 条信道</li><li>半双工通信——2 条</li><li>全双工通信——2 条</li></ol><h3 id="2-2-3- 串行传输 - 并行传输"><a href="#2-2-3- 串行传输 - 并行传输" class="headerlink" title="2.2.3 串行传输 &amp; 并行传输"></a>2.2.3 串行传输 &amp; 并行传输</h3><ol><li>串行传输——由低到高依次发送<ul><li>速度慢，费用低，适合远距离</li></ul></li><li>并行传输——8 条信道同时发送<ul><li>速度快，费用高，适合近距离</li></ul></li></ol><h3 id="2-2-4- 同步传输 - 异步传输"><a href="#2-2-4- 同步传输 - 异步传输" class="headerlink" title="2.2.4 同步传输 &amp; 异步传输"></a>2.2.4 同步传输 &amp; 异步传输</h3><ol><li>同步传输——数据传送以一个 <strong> 数据区块 </strong> 为单位</li><li>异步传输——将比特分成小组进行传送。<ul><li>可在任意时候发送数据。</li><li>传送数据时加一个字符起始位和一个字符终止位。</li></ul></li></ol><h3 id="2-2-5- 码元"><a href="#2-2-5- 码元" class="headerlink" title="2.2.5 码元"></a>2.2.5 码元 </h3><p> 用一个 <strong> 固定时长 </strong> 的<strong>信号波形 </strong> 代表不同离散数值的基本波形，是数字通信中数字信号的计量单位。</p><ul><li>M 进制码元：有 M 个离散状态</li><li>1 码元可携带多个比特的信息量<blockquote><p>4 进制码元→码元离散状态有 4 个→4 中信号波形 00、01、10、11</p></blockquote></li></ul><h3 id="2-2-6- 速率"><a href="#2-2-6- 速率" class="headerlink" title="2.2.6 速率"></a>2.2.6 速率 </h3><p> 数据的传输速率，表示单位时间内传输的数据量。</p><ol><li>码元传输速率——<font color=orange>1s 传输多少个码元</font><ul><li>码元速率与进制数无关，只和马原长度 T 有关。</li></ul></li><li>信息传输速率——<font color=orange>1s 传输多少个比特</font></li></ol><p><font color=red>关系：</font>若一个码元携带 n bit 的信息量，则 M Baud 的码元传输速率所对应的信息传输速率为 M×n bit&#x2F;s.</p><h3 id="2-2-7- 带宽"><a href="#2-2-7- 带宽" class="headerlink" title="2.2.7 带宽"></a>2.2.7 带宽</h3><ol><li>模拟信号系统中：单位 Hz。</li><li>数字设备中：点对点能通过的“<strong>最高数据率 </strong>” &#x2F; 单位时间内通过链路的数量。单位<strong> 比特每秒（bps）</strong></li></ol><h2 id="2-3- 奈氏准则 - 香农定理"><a href="#2-3- 奈氏准则 - 香农定理" class="headerlink" title="2.3 奈氏准则 &amp; 香农定理"></a>2.3 奈氏准则 &amp; 香农定理</h2><h3 id="2-3-1- 失真"><a href="#2-3-1- 失真" class="headerlink" title="2.3.1 失真"></a>2.3.1 失真</h3><ul><li>有失真但可识别</li><li>失真大无法识别</li><li>影响因素：码元传输速率、信号传输距离、噪声干扰、传输媒体质量</li><li>码间串扰：<strong>接收端 </strong> 收到的信号波形 <font color=red> 失去了码元之间清晰界限 </font> 的<strong>现象</strong>。</li></ul><h3 id="2-3-2- 奈氏准则（奈奎斯特定理）"><a href="#2-3-2- 奈氏准则（奈奎斯特定理）" class="headerlink" title="2.3.2 奈氏准则（奈奎斯特定理）"></a>2.3.2 奈氏准则（奈奎斯特定理）</h3><p>在理想低通条件下，为避免码间串扰，极限码元传输速率为 2W Baud，W 是信道带宽，单位是 Hz。</p><p><strong>理想低通信道下极限数据传输率</strong>&#x3D;<font color=red><strong>2Wlog<sub>2</sub>V</strong></font>(b&#x2F;s)</p><ul><li>W: 带宽 &emsp;&emsp;log<sub>2</sub>V: 几种码元的离散电平数目</li><li>码元传输速率有上限，超过则会出现码间串扰问题。</li><li>信道 <strong> 频带越宽</strong>，就可用更高速率进行马原的有效传输。</li><li><font color=green>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</font></li><li>要设法提高每个码元能携带更多个比特的信息量（多元制的解调方法）</li></ul><h3 id="2-3-3- 香农定理"><a href="#2-3-3- 香农定理" class="headerlink" title="2.3.3 香农定理"></a>2.3.3 香农定理 </h3><p> 在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p><p><strong>信道的极限数据传输速率</strong>&#x3D;<font color=green><strong>Wlog<sub>2</sub>(1+S&#x2F;N)</strong></font>(b&#x2F;s)</p><ul><li>S&#x2F;N: 信噪比 &emsp; 信噪比（dB）&#x3D;10log<sub>10</sub>(S&#x2F;N)</li><li>信道的 <strong> 带宽 </strong> 或信道中 <strong> 信噪比 </strong> 越大，信息的极限传输速率 <strong> 越高</strong>。</li><li>信息的传输速率低于极限信息传输速率时，一定有方法做到 <font color=red> 无差错的传输</font>。</li><li>奈氏准则（内）和香农定理（外），二者取小值为最大数据速率。</li></ul><h2 id="2-4- 编码 - 调制"><a href="#2-4- 编码 - 调制" class="headerlink" title="2.4 编码 &amp; 调制"></a>2.4 编码 &amp; 调制 </h2><h3 id="2-4-1- 基带信号与宽带信号"><a href="#2-4-1- 基带信号与宽带信号" class="headerlink" title="2.4.1 基带信号与宽带信号"></a>2.4.1 基带信号与宽带信号</h3><p> 信道：信号的传输媒介</p><ul><li>按传输信号分：模拟信道、数字信道</li><li>按传输介质分：无线信道、有线信道</li><li>信道上传送的信号：<ul><li>基带信号：发出的 <strong> 直接表达了要传输的信息的信号</strong>（传输距离近）</li><li>宽带信号：把基带信号经过 <strong> 载波调制 </strong> 后，把信号的 <strong> 频率范围搬移 </strong> 到<strong>较高的频段 </strong> 以便在信道中传输。（传输距离远）</li></ul></li></ul><h3 id="2-4-2- 编码与调制"><a href="#2-4-2- 编码与调制" class="headerlink" title="2.4.2 编码与调制"></a>2.4.2 编码与调制 </h3><p> 数据→数字信号：编码</p><p>数据→模拟信号：调制</p><h3 id="2-4-3- 数字数据编码为数字信号"><a href="#2-4-3- 数字数据编码为数字信号" class="headerlink" title="2.4.3 数字数据编码为数字信号"></a>2.4.3 数字数据编码为数字信号</h3><ol><li><strong>非归零编码【NRZ】</strong><ul><li><font color=orange><strong>高 1 低 0</strong></font>&emsp; 双方 <strong> 难以保持同步</strong></li></ul></li><li><strong>曼彻斯特编码</strong><ul><li>将一个码元分成两个相等间隔，前低后高为 1；反之为 0.</li><li><font color=orange>数据传输速率只有调制速率的 1&#x2F;2.</font></li></ul></li><li><strong>差分曼彻斯特编码</strong><ul><li><font color=orange><strong>同 1 异 0</strong></font></li><li>将一个码元分成两个相等间隔。</li><li>抗干扰性 <strong> 强</strong>于曼彻斯特编码。</li></ul></li><li>归零编码【RZ】<ul><li>将一个码元分成两个相等间隔。</li><li>每前半个码元恢复到 0.</li></ul></li><li>反向不归零编码【NRZI】</li><li>4B&#x2F;5B 编码</li></ol><h3 id="2-4-4 数字数据调制为模拟信号"><a href="#2-4-4 数字数据调制为模拟信号" class="headerlink" title="2.4.4 数字数据调制为模拟信号"></a>2.4.4 数字数据调制为模拟信号 </h3><p> 数字数据调制技术在发送端将<strong> 数字信号 </strong> 转换为 <strong> 模拟信号</strong></p><ul><li>调制：调幅、调频、调相、调幅＋调相</li></ul><h3 id="2-4-5- 模拟数据编码为数字信号"><a href="#2-4-5- 模拟数据编码为数字信号" class="headerlink" title="2.4.5 模拟数据编码为数字信号"></a>2.4.5 模拟数据编码为数字信号</h3><ul><li><strong>PCM 编码</strong>：对音频信号进行编码的脉码调制。</li><li>包括三步：抽样、量化、编码。</li><li><font color=red>f<sub>采样频率 </sub>≥2f<sub> 信号最高频率</sub></font> !</li></ul><h3 id="2-4-6- 模拟数据调制为模拟信号"><a href="#2-4-6- 模拟数据调制为模拟信号" class="headerlink" title="2.4.6 模拟数据调制为模拟信号"></a>2.4.6 模拟数据调制为模拟信号</h3><ul><li>在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；</li></ul><h2 id="2-5- 数据交换方式"><a href="#2-5- 数据交换方式" class="headerlink" title="2.5 数据交换方式"></a>2.5 数据交换方式</h2><ul><li>分为 <strong>1</strong> 电路交换、<strong>2</strong>报文交换、<strong>3</strong>分组交换。</li><li>2、3 是存储转发交换方式，分组交换包含数据报方式和虚电路方式。</li></ul><h3 id="2-5-1- 电路交换"><a href="#2-5-1- 电路交换" class="headerlink" title="2.5.1 电路交换"></a>2.5.1 电路交换</h3><ul><li>电路交换的阶段：建立连接（呼叫 &#x2F; 电路建立）→通信（数据传输）→释放连接（拆除电路）</li><li>特点：<strong>独占资源</strong>，适用于远程批处理信息传输或系统间实时性要求搞得大量数据传输情况。</li></ul><h3 id="2-5-2- 报文交换"><a href="#2-5-2- 报文交换" class="headerlink" title="2.5.2 报文交换"></a>2.5.2 报文交换 </h3><p> 报文：站点 <strong> 一次性要发送的数据块</strong>。</p><p>原理：无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用 <font color=red><strong> 存储转发方式</strong></font>.</p><ul><li>无建立连接时延，可随时发送报文。</li><li>动态分配线路。</li><li>只适用于数字信号，实时性差。</li></ul><h3 id="2-5-3- 分组交换"><a href="#2-5-3- 分组交换" class="headerlink" title="2.5.3 分组交换"></a>2.5.3 分组交换 </h3><p> 分组：网络系统把数据分割成小块，然后逐块发送，这种小块称为分组。</p><ul><li>分组：小数据块＋控制信息 &#x3D; 分组</li><li>分组交换网中要 <strong> 限制所传输的数据单位的长度</strong>，一般 128B.</li></ul><h3 id="2-5-4- 数据交换方式的选择"><a href="#2-5-4- 数据交换方式的选择" class="headerlink" title="2.5.4 数据交换方式的选择"></a>2.5.4 数据交换方式的选择</h3><ol><li>传送数据量大，传送时间远大于呼叫时，选择 <strong> 电路交换</strong>。电路交换传输时延最小。</li><li>端到端通路有很多段链路组成时，采用 <strong> 分组交换</strong>。</li><li>从信道利用率看，<strong>报文交换 </strong> 和<strong>分组交换 </strong> 优于电路交换，其中分组交换的时延更小，适合突发式数据通信。</li></ol><h2 id="2-6- 物理层传输介质"><a href="#2-6- 物理层传输介质" class="headerlink" title="2.6 物理层传输介质"></a>2.6 物理层传输介质 </h2><p> 传输介质：数据传输系统中在发送设备和接收设备之间的 <strong> 物理通路</strong>。</p><ul><li><font color=red>传输媒体不是物理层。</font></li><li>传输介质：<ul><li>导向性传输介质</li><li>非导向性传输介质</li></ul></li></ul><h3 id="2-6-1 导向型传输介质"><a href="#2-6-1 导向型传输介质" class="headerlink" title="2.6.1 导向型传输介质"></a>2.6.1 导向型传输介质</h3><ol><li>双绞线</li></ol><ul><li><strong>绞合可减少对相邻导线的电磁干扰。</strong></li><li>加上一个由 <font color=orange><strong> 金属丝 </strong></font> 编织成的屏蔽层——屏蔽双绞线（STP），无屏蔽层的是非屏蔽双绞线（UTP）。</li></ul><ol start="2"><li>同轴电缆<ul><li>基带同轴电缆——传送基带数字信号（局域网）</li><li>宽带同轴电缆——传送宽带信号（有线电视系统）</li></ul></li></ol><ul><li>同轴电缆 <strong> 抗干扰特性 </strong> 更好，<strong>传输距离 </strong> 更远，但价格更贵。</li></ul><ol start="3"><li>光纤</li></ol><ul><li>利用光导纤维传递 <strong> 光脉冲 </strong> 来进行通信。出现 <strong> 全反射 </strong> 原理，损耗 <strong> 低</strong>，适合远距离传输。</li><li>分类<ul><li>单模光纤——<strong>横向模式 </strong> 传输，损耗小，远距离传输</li><li>多模光纤——<strong>多种 </strong> 传输光信号模式的光纤，<strong>容易失真</strong>，近距离传输。</li></ul></li></ul><h3 id="2-6-2 非导向型传输介质"><a href="#2-6-2 非导向型传输介质" class="headerlink" title="2.6.2 非导向型传输介质"></a>2.6.2 非导向型传输介质</h3><ol><li>无线电波——信号向 <strong> 所有方向 </strong> 传播</li></ol><p>穿透能力强。<br>2. 微波——<strong>固定方向 </strong> 传播</p><p>   通信频率较高、数据率高。</p><ul><li>地面微波接力通信</li><li>卫星通信</li></ul><ol start="3"><li>红外线、激光——<strong>固定方向 </strong> 传播</li></ol><p>要把要传输的信号分别转换为各自的信号格式。</p><h2 id="2-7- 物理层设备"><a href="#2-7- 物理层设备" class="headerlink" title="2.7 物理层设备"></a>2.7 物理层设备</h2><h3 id="2-7-1- 中继器"><a href="#2-7-1- 中继器" class="headerlink" title="2.7.1 中继器"></a>2.7.1 中继器</h3><ul><li>功能：对信号进行 <strong> 再生（数字信号）和还原</strong>。</li><li>中继器两端：适用于完全相同的 <font color=blue> 两类 </font> 网络的互连。傻瓜层，不会存储转发。</li><li>5-4-3 规则：不超过 5 个网段，最多只能有 4 个物理层网络设备，只有 3 个段可连接计算机。</li></ul><h3 id="2-7-2- 集线器（多口中继器）"><a href="#2-7-2- 集线器（多口中继器）" class="headerlink" title="2.7.2 集线器（多口中继器）"></a>2.7.2 集线器（多口中继器）</h3><ul><li>功能：**<font color=orange>再生，放大信号</font>**</li><li>集线器不能分割冲突域。→连载集线器上的工作主机平分带宽。</li></ul><h1 id="第三章 - 数据链路层"><a href="# 第三章 - 数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1- 数据链路层的功能"><a href="#3-1- 数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241021204143.png" alt="20241021204143"></p><h2 id="3-2- 组帧"><a href="#3-2- 组帧" class="headerlink" title="3.2 组帧"></a>3.2 组帧</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241021204244.png" alt="20241021204244"></p><h2 id="3-3- 差错控制"><a href="#3-3- 差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241021204413.png" alt="20241021204413"></p><h3 id="3-3-1- 奇偶校验码"><a href="#3-3-1- 奇偶校验码" class="headerlink" title="3.3.1 奇偶校验码"></a>3.3.1 奇偶校验码</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241021204457.png" alt="20241021204457"></p><h3 id="3-3-2- 循环冗余校验码"><a href="#3-3-2- 循环冗余校验码" class="headerlink" title="3.3.2 循环冗余校验码"></a>3.3.2 循环冗余校验码</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241021204601.png" alt="20241021204601"></p><h3 id="3-3-3- 纠错控制——海明码"><a href="#3-3-3- 纠错控制——海明码" class="headerlink" title="3.3.3 纠错控制——海明码"></a>3.3.3 纠错控制——海明码</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241021204715.png" alt="20241021204715"></p><h2 id="3-4- 流量控制和可靠传输"><a href="#3-4- 流量控制和可靠传输" class="headerlink" title="3.4 流量控制和可靠传输"></a>3.4 流量控制和可靠传输</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241022203047.png" alt="20241022203047"></p><h3 id="3-4-1- 停止等待协议"><a href="#3-4-1- 停止等待协议" class="headerlink" title="3.4.1 停止等待协议"></a>3.4.1 停止等待协议</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241022203225.png" alt="20241022203225"></p><h3 id="3-4-2- 后退 N 帧协议"><a href="#3-4-2- 后退 N 帧协议" class="headerlink" title="3.4.2 后退 N 帧协议"></a>3.4.2 后退 N 帧协议</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241022214755.png" alt="20241022214755"></p><h3 id="3-4-3- 选择重传协议"><a href="#3-4-3- 选择重传协议" class="headerlink" title="3.4.3 选择重传协议"></a>3.4.3 选择重传协议</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241022214825.png" alt="20241022214825"></p><h3 id="3-4-4- 三种协议的信道利用率分析"><a href="#3-4-4- 三种协议的信道利用率分析" class="headerlink" title="3.4.4 三种协议的信道利用率分析"></a>3.4.4 三种协议的信道利用率分析</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241023135639.png" alt="20241023135639"></p><h2 id="3-5- 介质访问控制"><a href="#3-5- 介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h2><h3 id="3-5-1- 信道划分介质访问控制"><a href="#3-5-1- 信道划分介质访问控制" class="headerlink" title="3.5.1 信道划分介质访问控制"></a>3.5.1 信道划分介质访问控制</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024103100.png" alt="20241024103100"></p><h3 id="3-5-2- 随机访问介质访问控制——ALOHA、CSMA"><a href="#3-5-2- 随机访问介质访问控制——ALOHA、CSMA" class="headerlink" title="3.5.2 随机访问介质访问控制——ALOHA、CSMA"></a>3.5.2 随机访问介质访问控制——ALOHA、CSMA</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024105544.png" alt="20241024105544"></p><h3 id="3-5-3- 随机访问介质访问控制——CSMA-CD"><a href="#3-5-3- 随机访问介质访问控制——CSMA-CD" class="headerlink" title="3.5.3 随机访问介质访问控制——CSMA&#x2F;CD"></a>3.5.3 随机访问介质访问控制——CSMA&#x2F;CD</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024105733.png" alt="20241024105733"></p><h3 id="3-5-4- 随机访问介质访问控制——CSMA-CA 协议"><a href="#3-5-4- 随机访问介质访问控制——CSMA-CA 协议" class="headerlink" title="3.5.4 随机访问介质访问控制——CSMA&#x2F;CA 协议"></a>3.5.4 随机访问介质访问控制——CSMA&#x2F;CA 协议</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024110059.png" alt="20241024110059"></p><h3 id="3-5-5- 令牌传递协议"><a href="#3-5-5- 令牌传递协议" class="headerlink" title="3.5.5 令牌传递协议"></a>3.5.5 令牌传递协议</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024131122.png" alt="20241024131122"></p><h2 id="3-6- 局域网与 IEEE"><a href="#3-6- 局域网与 IEEE" class="headerlink" title="3.6 局域网与 IEEE"></a>3.6 局域网与 IEEE</h2><h3 id="3-6-1-802-3"><a href="#3-6-1-802-3" class="headerlink" title="3.6.1 802.3"></a>3.6.1 802.3</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024200829.png" alt="20241024200829"></p><h3 id="3-6-2-VLAN 虚拟局域网"><a href="#3-6-2-VLAN 虚拟局域网" class="headerlink" title="3.6.2 VLAN 虚拟局域网"></a>3.6.2 VLAN 虚拟局域网</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024200951.png" alt="20241024200951"></p><h3 id="3-6-3-IEEE-802-11 无线局域网"><a href="#3-6-3-IEEE-802-11 无线局域网" class="headerlink" title="3.6.3 IEEE 802.11 无线局域网"></a>3.6.3 IEEE 802.11 无线局域网</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024201100.png" alt="20241024201100"></p><h2 id="3-7- 广域网"><a href="#3-7- 广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h2><ul><li>PPP 协议</li><li>HDLC 协议</li></ul><p>二者只支持全双工链路，都可实现透明传输，都可实现差错检测，但不纠正差错。</p><h2 id="3-8- 以太网交换机"><a href="#3-8- 以太网交换机" class="headerlink" title="3.8 以太网交换机"></a>3.8 以太网交换机</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241024201415.png" alt="20241024201415"></p><h1 id="第四章 - 网络层"><a href="# 第四章 - 网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1- 网络层的功能"><a href="#4-1- 网络层的功能" class="headerlink" title="4.1 网络层的功能"></a>4.1 网络层的功能</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241029172923.png" alt="20241029172923"></p><h2 id="4-2-IPv4"><a href="#4-2-IPv4" class="headerlink" title="4.2 IPv4"></a>4.2 IPv4</h2><h3 id="4-2-1-IPv4 分组"><a href="#4-2-1-IPv4 分组" class="headerlink" title="4.2.1 IPv4 分组"></a>4.2.1 IPv4 分组</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241029173210.png" alt="20241029173210"></p><h3 id="4-2-2-IP 地址（最初分类方案）"><a href="#4-2-2-IP 地址（最初分类方案）" class="headerlink" title="4.2.2 IP 地址（最初分类方案）"></a>4.2.2 IP 地址（最初分类方案）</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241029173635.png" alt="20241029173635"></p><h3 id="4-2-3- 子网划分和子网掩码"><a href="#4-2-3- 子网划分和子网掩码" class="headerlink" title="4.2.3 子网划分和子网掩码"></a>4.2.3 子网划分和子网掩码</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241029201047.png" alt="20241029201047"></p><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241029201153.png" alt="20241029201153"></p><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241029201223.png" alt="20241029201223"></p><h3 id="4-2-4- 无分类编址"><a href="#4-2-4- 无分类编址" class="headerlink" title="4.2.4 无分类编址"></a>4.2.4 无分类编址</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241104162727.png" alt="20241104162727"></p><h3 id="4-2-5- 路由聚合"><a href="#4-2-5- 路由聚合" class="headerlink" title="4.2.5 路由聚合"></a>4.2.5 路由聚合</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241104164525.png" alt="20241104164525"></p><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20241104164615.png" alt="20241104164615"></p><h3 id="4-2-6- 网络地址转换 NAT"><a href="#4-2-6- 网络地址转换 NAT" class="headerlink" title="4.2.6 网络地址转换 NAT"></a>4.2.6 网络地址转换 NAT</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250209172842.png" alt="20250209172842"></p><h3 id="4-2-7- 地址解析协议 ARP"><a href="#4-2-7- 地址解析协议 ARP" class="headerlink" title="4.2.7 地址解析协议 ARP"></a>4.2.7 地址解析协议 ARP</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250209173113.png" alt="20250209173113"></p><h3 id="4-2-8- 动态主机配置协议 DHCP"><a href="#4-2-8- 动态主机配置协议 DHCP" class="headerlink" title="4.2.8 动态主机配置协议 DHCP"></a>4.2.8 动态主机配置协议 DHCP</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250209173316.png" alt="20250209173316"></p><h2 id="4-3-IPV6"><a href="#4-3-IPV6" class="headerlink" title="4.3 IPV6"></a>4.3 IPV6</h2><h2 id="4-4- 路由算法与路由协议"><a href="#4-4- 路由算法与路由协议" class="headerlink" title="4.4 路由算法与路由协议"></a>4.4 路由算法与路由协议 </h2><h2 id="4-5-IP 组播"><a href="#4-5-IP 组播" class="headerlink" title="4.5 IP 组播"></a>4.5 IP 组播</h2><h2 id="4-6- 移动 IP"><a href="#4-6- 移动 IP" class="headerlink" title="4.6 移动 IP"></a>4.6 移动 IP</h2><h1 id="第五章 - 传输层"><a href="# 第五章 - 传输层" class="headerlink" title="第五章 传输层"></a> 第五章 传输层</h1><h2 id="5-1- 传输层提供的服务"><a href="#5-1- 传输层提供的服务" class="headerlink" title="5.1 传输层提供的服务"></a>5.1 传输层提供的服务</h2><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250210203026.png" alt="20250210203026"></p><h2 id="5-2-UDP 协议"><a href="#5-2-UDP 协议" class="headerlink" title="5.2 UDP 协议"></a>5.2 UDP 协议</h2><h3 id="5-2-1-UDP 数据报"><a href="#5-2-1-UDP 数据报" class="headerlink" title="5.2.1 UDP 数据报"></a>5.2.1 UDP 数据报</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250210203142.png" alt="20250210203142"></p><h3 id="5-2-2-UDP 检验"><a href="#5-2-2-UDP 检验" class="headerlink" title="5.2.2 UDP 检验"></a>5.2.2 UDP 检验</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250210203311.png" alt="20250210203311"></p><h2 id="5-3-TCP 协议"><a href="#5-3-TCP 协议" class="headerlink" title="5.3 TCP 协议"></a>5.3 TCP 协议</h2><h3 id="5-3-1-TCP 报文段"><a href="#5-3-1-TCP 报文段" class="headerlink" title="5.3.1 TCP 报文段"></a>5.3.1 TCP 报文段</h3><p><img src="https://raw.githubusercontent.com/EngineHeating/picgo_2/main/20250210203514.png" alt="20250210203514"></p><ul><li>序号：标记数据部分第一个字节在原始字节流中的位置</li><li>确认号：“累计确认” ，反馈：序号在该确认号之前的所有字节都已经正确收到</li><li>只有握手 1、握手 2 的 SYN&#x3D;1</li><li>只有挥手 1、挥手 3 的 FIN&#x3D;1</li><li>窗口：接收窗口大小。从 ack_seq 算起还能接受多少数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MTALAB 中 commsrc.combinedjitter 构造组合抖动生成器对象</title>
      <link href="/2024/07/08/Matlab%E6%B7%BB%E5%8A%A0%E7%BB%84%E5%90%88%E6%8A%96%E5%8A%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2024/07/08/Matlab%E6%B7%BB%E5%8A%A0%E7%BB%84%E5%90%88%E6%8A%96%E5%8A%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MTALAB- 中 -commsrc-combinedjitter- 构造组合抖动生成器对象"><a href="#MTALAB- 中 -commsrc-combinedjitter- 构造组合抖动生成器对象" class="headerlink" title="MTALAB 中 commsrc.combinedjitter 构造组合抖动生成器对象"></a>MTALAB 中 commsrc.combinedjitter 构造组合抖动生成器对象</h1><h2 id="1- 两种函数"><a href="#1- 两种函数" class="headerlink" title="1. 两种函数"></a>1. 两种函数</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">combJitt = commsrc.combinedjitter</span><br><span class="line">combJitt = commsrc.combinedjitter(Name,Value)</span><br></pre></td></tr></table></figure><h2 id="2- 定义"><a href="#2- 定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>combJitt &#x3D; commsrc.combinedjitter 构造一个默认的组合抖动生成器对象 combJitt，所有的抖动组件都被禁用。</p><p>使用该对象可生成抖动样本，其中包括随机、周期性和狄拉克分量的任意组合。</p><hr><p>combJitt &#x3D; commsrc.combinedjitter(Name,Value)创建一个组合抖动生成器对象，并将指定的属性 Name 设置为指定的 Value。可以任意顺序指定附加的名称 - 值对参数，如(Name1,Value1，…，NameN,ValueN)。</p><h2 id="3- 案例"><a href="#3- 案例" class="headerlink" title="3. 案例"></a>3. 案例 </h2><h3 id="3-1- 生成 500 个由随机和周期抖动组成的抖动样本"><a href="#3-1- 生成 500 个由随机和周期抖动组成的抖动样本" class="headerlink" title="3.1 生成 500 个由随机和周期抖动组成的抖动样本"></a>3.1 生成 500 个由随机和周期抖动组成的抖动样本</h3><p> 创建一个 commsrc.combinedjitter 对象，配置为应用随机和周期性抖动组件的组合。使用名称 - 值对来启用 RandomJitter 和 PeriodicJitter，并分配抖动设置。设置随机抖动的标准差为 2e-4 秒，周期抖动的幅度为 5e-4 秒，周期抖动的频率为 2hz。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% step1: 创建一个 commsrc.combinedjitter 对象，对抖动成分进行设置</span></span><br><span class="line">numSamples = <span class="number">500</span>;</span><br><span class="line">combJitt = commsrc.combinedjitter(...</span><br><span class="line">    <span class="string">&#x27;RandomJitter&#x27;</span>,<span class="string">&#x27;on&#x27;</span>, ...</span><br><span class="line">    <span class="string">&#x27;RandomStd&#x27;</span>,<span class="number">2e-4</span>, ...</span><br><span class="line">    <span class="string">&#x27;PeriodicJitter&#x27;</span>,<span class="string">&#x27;on&#x27;</span>, ...</span><br><span class="line">    <span class="string">&#x27;PeriodicAmplitude&#x27;</span>,<span class="number">5e-4</span>, ...</span><br><span class="line">    <span class="string">&#x27;PeriodicFrequencyHz&#x27;</span>,<span class="number">200</span>);  </span><br><span class="line"><span class="comment">% step2: 使用生成方法 generate 创建组合抖动样本。</span></span><br><span class="line">y = generate(combJitt,numSamples);</span><br><span class="line">x = [<span class="number">0</span>:numSamples<span class="number">-1</span>];</span><br><span class="line"><span class="comment">% step3: 绘制抖动样本</span></span><br><span class="line"><span class="built_in">plot</span>(x/combJitt.SamplingFrequency,y);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (seconds)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Jitter (seconds)&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2- 生成一个 PRBS7 信号并添加 RJ 和 DJ"><a href="#3-2- 生成一个 PRBS7 信号并添加 RJ 和 DJ" class="headerlink" title="3.2 生成一个 PRBS7 信号并添加 RJ 和 DJ"></a>3.2 生成一个 PRBS7 信号并添加 RJ 和 DJ</h3><p>可运行的代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 利用模式生成器对象生成一个二进制非归零 (NRZ) 信号。查看 NRZ 信号与不抖动应用到信号。</span></span><br><span class="line"><span class="comment">% 初始化系统参数</span></span><br><span class="line">Fs = <span class="number">10000</span>; <span class="comment">% Sample rate 采样率</span></span><br><span class="line">Rs = <span class="number">50</span>; <span class="comment">% Symbol rate 符号率</span></span><br><span class="line">sps = Fs / Rs; <span class="comment">% Number of samples per symbol 每个符号的样本数</span></span><br><span class="line">Trise = <span class="number">1</span> / (<span class="number">5</span> * Rs); <span class="comment">% Rise time of the NRZ signal NRZ 信号的上升时间</span></span><br><span class="line">Tfall = <span class="number">1</span> / (<span class="number">5</span> * Rs); <span class="comment">% Fall time of the NRZ signal NRZ 信号的下降时间</span></span><br><span class="line">frameLen = <span class="number">100</span>; <span class="comment">% Number of symbols in a frame 一帧中的符号数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建无抖动的 PRBS 信号源对象</span></span><br><span class="line">src_no_jitter = commsrc.pattern(<span class="string">&#x27;SamplingFrequency&#x27;</span>, Fs, ...</span><br><span class="line">    <span class="string">&#x27;SamplesPerSymbol&#x27;</span>, sps, <span class="string">&#x27;RiseTime&#x27;</span>, Trise, <span class="string">&#x27;FallTime&#x27;</span>, Tfall, ...</span><br><span class="line">    <span class="string">&#x27;DataPattern&#x27;</span>, <span class="string">&#x27;PRBS7&#x27;</span>); <span class="comment">% 使用 PRBS7 作为数据模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成无抖动的 PRBS 信号</span></span><br><span class="line">message_no_jitter = generate(src_no_jitter, frameLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建一个包含随机抖动和周期抖动的抖动对象</span></span><br><span class="line">jitter = commsrc.combinedjitter(<span class="string">&#x27;RandomJitter&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;RandomStd&#x27;</span>, <span class="number">2e-4</span>, ...</span><br><span class="line">                                <span class="string">&#x27;PeriodicJitter&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;PeriodicAmplitude&#x27;</span>, <span class="number">1e-4</span>, ...</span><br><span class="line">                                <span class="string">&#x27;PeriodicFrequency&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建一个带抖动的 PRBS 信号源对象</span></span><br><span class="line">src_with_jitter = commsrc.pattern(<span class="string">&#x27;SamplingFrequency&#x27;</span>, Fs, ...</span><br><span class="line">    <span class="string">&#x27;SamplesPerSymbol&#x27;</span>, sps, <span class="string">&#x27;RiseTime&#x27;</span>, Trise, <span class="string">&#x27;FallTime&#x27;</span>, Tfall, ...</span><br><span class="line">    <span class="string">&#x27;DataPattern&#x27;</span>, <span class="string">&#x27;PRBS7&#x27;</span>, <span class="string">&#x27;Jitter&#x27;</span>, jitter); <span class="comment">% 使用 PRBS7 作为数据模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成带抖动的 PRBS 信号</span></span><br><span class="line">message_with_jitter = generate(src_with_jitter, frameLen);</span><br><span class="line">message_with_jitter = message_with_jitter(<span class="number">1</span>:<span class="number">20000</span>);</span><br><span class="line"><span class="comment">% 创建时间向量</span></span><br><span class="line">t = (<span class="number">0</span>:<span class="built_in">length</span>(message_no_jitter)<span class="number">-1</span>) / Fs;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制时域图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, message_no_jitter, <span class="string">&#x27;b&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(t, message_with_jitter, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27; 无抖动 &#x27;</span>, <span class="string">&#x27; 带抖动 &#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;PRBS 信号时域图对比 &#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27; 时间 (秒)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27; 幅度 &#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求 TIE 图 -------------</span></span><br><span class="line">signal_out = [t&#x27;,message_no_jitter];</span><br><span class="line">signal_in = [t&#x27;,message_with_jitter];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求上升沿下降沿与中线的交点</span></span><br><span class="line">[edge_interp_in,piont_index_in]=func_sig_edge(signal_in,<span class="number">0.5</span>,<span class="number">5</span>);</span><br><span class="line">[edge_interp_out,piont_index_out]=func_sig_edge(signal_out,<span class="number">0.5</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">TIE_length = <span class="built_in">min</span>(<span class="built_in">length</span>(edge_interp_in), <span class="built_in">length</span>(edge_interp_out));</span><br><span class="line"><span class="comment">% 求交点的时间差，即 TIE</span></span><br><span class="line">TIE = <span class="built_in">zeros</span>(TIE_length, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:TIE_length</span><br><span class="line">    TIE(<span class="built_in">i</span>) = edge_interp_out(<span class="built_in">i</span>) - edge_interp_in(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%TIE 直方图分布</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>);</span><br><span class="line">histogram(TIE, <span class="number">200</span>);</span><br><span class="line"><span class="comment">%TIE 趋势图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line">t_TIE =  <span class="number">1</span> : <span class="number">1</span> : <span class="built_in">length</span>(TIE);</span><br><span class="line"><span class="built_in">plot</span>(t_TIE,TIE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前发现添加抖动是通过 generate 函数进行添加，该 generate 方法在 pattern201 行下。调试进入该函数如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">generate</span><span class="params">(this, N)</span></span></span><br><span class="line"><span class="comment">%GENERATE  Generate a modulated pattern</span></span><br><span class="line"><span class="comment">%   Y = GENERATE(H, N) generates an N symbol modulated pattern based on the</span></span><br><span class="line"><span class="comment">%   pattern generator object H.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   See also COMMSRC.PATTERN, COMMSRC.PATTERN/STD181TOIDEAL,</span></span><br><span class="line"><span class="comment">%   COMMSRC.PATTERN/IDEALTOSTD181, COMMSRC.PATTERN/RESET,</span></span><br><span class="line"><span class="comment">%   COMMSRC.PATTERN/COMPUTEDCD, COMMSRC.PATTERN/DISP. </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% Check input arguments</span></span><br><span class="line">            narginchk(<span class="number">2</span>, <span class="number">2</span>);    <span class="comment">% 检查输入参数个数为 2-2</span></span><br><span class="line">            sigdatatypes.checkFinitePosIntScalar(<span class="string">&#x27;GENERATE&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, N);  <span class="comment">% 检查 N 是否为有限正整数标量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% Get data bits</span></span><br><span class="line">            <span class="keyword">if</span> strncmp(this.DataPattern, <span class="string">&#x27;U&#x27;</span>, <span class="number">1</span>)    <span class="comment">% 判断信号数据是不是 User Defined</span></span><br><span class="line">                <span class="comment">% Get bits from user data</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">% Get data vector and counter</span></span><br><span class="line">                userDataPattern = this.UserDataPattern(:);</span><br><span class="line">                cnt = this.UserDataCnt;</span><br><span class="line">                len = <span class="built_in">length</span>(userDataPattern);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> len &lt; N</span><br><span class="line">                    <span class="comment">% Length of user data is less than requested length</span></span><br><span class="line">                    data = <span class="built_in">repmat</span>(userDataPattern, <span class="built_in">ceil</span>((N+cnt)/len), <span class="number">1</span>);</span><br><span class="line">                    data = data(cnt:cnt+N<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">% Length of user data is greater than or equal to the</span></span><br><span class="line">                    <span class="comment">% requested length </span></span><br><span class="line">                    <span class="keyword">if</span> (cnt+N) &gt; len</span><br><span class="line">                        data = [userDataPattern(cnt:<span class="keyword">end</span>); ...</span><br><span class="line">                            userDataPattern(<span class="number">1</span>:N+cnt-len<span class="number">-1</span>)];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        data = userDataPattern(cnt:cnt+N<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">% Update counter</span></span><br><span class="line">                this.UserDataCnt = <span class="built_in">mod</span>(cnt + N - <span class="number">1</span>, len) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">% Get bits from PRBS generator</span></span><br><span class="line">                hDataGen = this.DataPatternGen;</span><br><span class="line">                data = hDataGen(N);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> this.SamplingFrequency ~= this.Jitter.SamplingFrequency</span><br><span class="line">              this.Jitter.SamplingFrequency = this.SamplingFrequency;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% Generate jitter samples</span></span><br><span class="line">            jitter = generate(this.Jitter, N);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% Generate the jitter injected pulse.  Note that the pulse generator</span></span><br><span class="line">            <span class="comment">% requires jitter values to be in samples.</span></span><br><span class="line">            y = generate(this.PulseGenerator, data, ...</span><br><span class="line">                jitter*this.SamplingFrequency);<span class="comment">% *** 产生抖动注入脉冲</span></span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面最后一行 generate 函数进入如下，这里是如何将产生的抖动成分添加到 PRBS 信号的核心成分。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">generate</span><span class="params">(this, data, varargin)</span></span></span><br><span class="line"><span class="comment">%GENERATE   Generate NRZ modulated signal</span></span><br><span class="line"><span class="comment">%   GENERATE(H, DATA) modulates input data bits, DATA, using NRZ modulated</span></span><br><span class="line"><span class="comment">%   signaling.  DATA must be a column vector with element values 0 or 1.  The</span></span><br><span class="line"><span class="comment">%   NRZ pulse properties are defined by the NRZ pulse generator object H.  </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   GENERATE(H, DATA, JITTER) generates NRZ modulated signals as in the previous</span></span><br><span class="line"><span class="comment">%   case but also injects jitter.  JITTER is a column vector of real jitter</span></span><br><span class="line"><span class="comment">%   values.  Jitter values are normalized with sampling frequency.  The length</span></span><br><span class="line"><span class="comment">%   of DATA and JITTER vectors must be equal.  The difference of consecutive</span></span><br><span class="line"><span class="comment">%   jitter values must be less than the symbol duration. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   EXAMPLES:</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%     % Create an NRZ pulse generator object</span></span><br><span class="line"><span class="comment">%     h = commsrc.nrz;</span></span><br><span class="line"><span class="comment">%     % Generate binary data</span></span><br><span class="line"><span class="comment">%     data = rand(20, 1) &gt; 0.5;</span></span><br><span class="line"><span class="comment">%     % Generate NRZ modulated signal</span></span><br><span class="line"><span class="comment">%     y = generate(h, data);</span></span><br><span class="line"><span class="comment">%     plot(y)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%     % Generate random jitter</span></span><br><span class="line"><span class="comment">%     jitter = randn(20, 1)/50;</span></span><br><span class="line"><span class="comment">%     % Generate NRZ modulated signal and inject jitter</span></span><br><span class="line"><span class="comment">%     y = generate(h, data, jitter);</span></span><br><span class="line"><span class="comment">%     hold on; plot(y, &#x27;r&#x27;); hold off;</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   See also COMMSRC.NRZ, COMMSRC.NRZ/DISP, COMMSRC.NRZ/RESET.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Copyright 2008-2009 The MathWorks, Inc.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Parse and validate input arguments</span></span><br><span class="line">[jitter dataLen] = parseGenerateArgs(this, data, varargin&#123;:&#125;);<span class="comment">% 这里进入函数，检查一些问题，最终得到抖动成分数据和 jitter 原输入信号长度 dataLen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Gather needed information to generate the output</span></span><br><span class="line">sqrtEps = <span class="built_in">sqrt</span>(<span class="built_in">eps</span>);</span><br><span class="line">riseRate = this.RiseRate;</span><br><span class="line">fallRate = this.FallRate;</span><br><span class="line">numRiseSamps = this.NumRiseSamps;</span><br><span class="line">numFallSamps = this.NumFallSamps;</span><br><span class="line">high = this.HighLevel;</span><br><span class="line">low = this.LowLevel;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Append the last transmitted data symbol index to DATA</span></span><br><span class="line">data = [this.LastData; data];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Obtain symbols from symbol numbers</span></span><br><span class="line">symbols = this.OutputLevels(data+<span class="number">1</span>);<span class="comment">% 这里把 01 信号变成了 -1 和 1 信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Get jittered clock ******** 核心部分，将抖动成分掺入时钟 *********</span></span><br><span class="line">[clk nClk rClk] = getJitteredClock(this, dataLen, jitter);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Determine difference between adjacent data levels.  We will use this vector to</span></span><br><span class="line"><span class="comment">% decide if we have a falling transition, a rising transition, or no transition.</span></span><br><span class="line">change = diff(symbols);<span class="comment">% 确定相邻数据电平之间的差异。我们将使用这个向量来判断是下降过渡、上升过渡还是没有过渡。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Generate output. </span></span><br><span class="line">y = <span class="built_in">zeros</span>(nClk(<span class="keyword">end</span>)<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> p=<span class="number">1</span>:<span class="built_in">length</span>(clk)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> change(p) &lt; -sqrtEps</span><br><span class="line">        <span class="comment">% This is a high-to-low transition</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% Calculate the end time of the integer part of the fall time</span></span><br><span class="line">        t1 = <span class="built_in">floor</span>(clk(p)+numFallSamps);</span><br><span class="line">        </span><br><span class="line">        y(nClk(p)) = high + fallRate*rClk(p);</span><br><span class="line">        <span class="keyword">for</span> q=nClk(p)+<span class="number">1</span>:t1</span><br><span class="line">            y(q) = y(q<span class="number">-1</span>) + fallRate;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        y(t1+<span class="number">1</span>:nClk(p+<span class="number">1</span>)<span class="number">-1</span>) = low;</span><br><span class="line">    <span class="keyword">elseif</span> change(p) &gt; sqrtEps</span><br><span class="line">        <span class="comment">% This is a low-to-high transition</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% Calculate the end time of the integer part of the rise time</span></span><br><span class="line">        t1 = <span class="built_in">floor</span>(clk(p)+numRiseSamps);</span><br><span class="line">        </span><br><span class="line">        y(nClk(p)) = low + riseRate*rClk(p);</span><br><span class="line">        <span class="keyword">for</span> q=nClk(p)+<span class="number">1</span>:t1</span><br><span class="line">            y(q) = y(q<span class="number">-1</span>) + riseRate;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        y(t1+<span class="number">1</span>:nClk(p+<span class="number">1</span>)<span class="number">-1</span>) = high;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">% No transition</span></span><br><span class="line">        y(nClk(p):nClk(p+<span class="number">1</span>)<span class="number">-1</span>) = symbols(p+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Store state</span></span><br><span class="line">this.LastData = data(p+<span class="number">1</span>);</span><br><span class="line">this.LastJitter = jitter(<span class="keyword">end</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常频时钟恢复方式原理</title>
      <link href="/2024/06/11/%E5%B8%B8%E9%A2%91%E6%97%B6%E9%92%9F%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2024/06/11/%E5%B8%B8%E9%A2%91%E6%97%B6%E9%92%9F%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常频时钟恢复方式原理"><a href="# 常频时钟恢复方式原理" class="headerlink" title="常频时钟恢复方式原理"></a>常频时钟恢复方式原理</h1><blockquote><p>本文来自 KEYSIGHT 官方文档。</p></blockquote><p>时钟恢复方法的恒定频率设置允许从这些选项中进行选择:</p><ul><li><p>全自动：全自动恒频时钟恢复不需要输入有关信号的任何信息。</p><p>该算法寻找时间上最窄的脉冲，并假定它是孤立的 1 或 0。(对于有大量符号间干扰 (ISI) 的信号，特别窄的脉冲宽度会使该算法失效，从而导致名义数据速率过快。)</p><p>然后，该算法根据该时间确定其他脉冲宽度中的比特数，以确定每个宽度中的比特数。</p></li><li><p>半自动：半自动恒频时钟恢复允许通过输入标称数据速率自己“播种”算法。这使得算法运行得更快，因为它不需要两次遍历数据。</p><p>  然后，该算法计算出平均实际位宽，并准确地计算出每个脉冲的位数。</p><p>  输入的 <strong> 标称数据速率 </strong> 是算法的种子。</p></li><li><p>手动：使用用户提供的数据速率。</p><p>  用户输入的标称数据速率应该是串行数据流的单位间隔的倒数。</p><p>  在全自动或半自动选项中，测量实际数据速率和时钟相位，使平均时间间隔误差 (TIE) 为 0。由此创建恢复的时钟。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时钟恢复 </tag>
            
            <tag> 研究生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外文文献检索</title>
      <link href="/2024/04/09/%E5%A4%96%E6%96%87%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/"/>
      <url>/2024/04/09/%E5%A4%96%E6%96%87%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="外文文献检索"><a href="# 外文文献检索" class="headerlink" title="外文文献检索"></a>外文文献检索 </h1><p> 外文文献检索主要基于以下三个网站展开：</p><ol><li>web of science：<a href="https://webofscience.clarivate.cn/wos/alldb/basic-search">https://webofscience.clarivate.cn/wos/alldb/basic-search</a> </li><li>IEEE：<a href="https://ieeexplore.ieee.org/Xplore/home.jsp">https://ieeexplore.ieee.org/Xplore/home.jsp</a></li><li>Engineering Village：<a href="https://www.engineeringvillage.com/search/quick.url">https://www.engineeringvillage.com/search/quick.url</a></li></ol><p>网站 1 类似于知网的检索，库最全，适合首要考虑。网站 2 是 IEEE 检索，专门定向 IEEE，网站 3 是 EI 检索，含金量相对前二者较低。</p><p>以网站 1 为例，找到一篇文章主要关注 3 个点：影响因子，分区（Q1），中科院分区</p>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保存并读取 N9030A 波形数据并作图</title>
      <link href="/2024/03/20/%E4%BF%9D%E5%AD%98%E5%B9%B6%E8%AF%BB%E5%8F%96N9030%E6%B3%A2%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BD%9C%E5%9B%BE/"/>
      <url>/2024/03/20/%E4%BF%9D%E5%AD%98%E5%B9%B6%E8%AF%BB%E5%8F%96N9030%E6%B3%A2%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BD%9C%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="保存并读取 N9030A 波形数据并作图"><a href="# 保存并读取 N9030A 波形数据并作图" class="headerlink" title="保存并读取 N9030A 波形数据并作图"></a>保存并读取 N9030A 波形数据并作图 </h1><p> 本例用到 QCustomPlot 库，用于绘制二维图，基础配置见上文。</p><blockquote><p>一开始希望保存为 CSV 文件，但查找帮助文档后发现唯独保存为 DATA（CSV）格式没有对应的 SPCI 指令。多次尝试无果后换为保存为 state 格式尝试，最终可以实现。</p><ul><li><strong>state 格式 </strong> 可以保存观测点、mark 点、中心频率等分析仪的设置参数，并且可 recall 后加载到分析仪上原封不动的显示。<strong>csv 格式 </strong> 基本为用逗号隔开的纯文本格式。</li></ul></blockquote><p>下面是一个可运行的函数，点击按钮后，QWidegt 控件会进行绘图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_TextButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接 N9030A 并加载 State 文件</span></span><br><span class="line">        status = <span class="built_in">viOpenDefaultRM</span>(&amp;defaultRM);</span><br><span class="line">        <span class="built_in">viOpen</span>(defaultRM,<span class="string">&quot;TCPIP0::192.168.80.69::inst0::INSTR&quot;</span>,VI_NULL,VI_NULL,&amp;instrument);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        QString str = <span class="string">&quot;:MMEMory:STORe:STATe &#x27;state2.state&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">char</span>*  ch;</span><br><span class="line">        QByteArray ba = str.<span class="built_in">toLatin1</span>(); <span class="comment">// QString 类型转 char</span></span><br><span class="line">        ch=ba.<span class="built_in">data</span>();</span><br><span class="line">        status = <span class="built_in">viWrite</span>(instrument,(ViBuf)ch,<span class="built_in">strlen</span>(ch),&amp;writeCount);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        str = <span class="string">&quot;:MMEMory:LOAD:STATe &#x27;state2.state&#x27;&quot;</span>;</span><br><span class="line">        ba = str.<span class="built_in">toLatin1</span>();</span><br><span class="line">        ch=ba.<span class="built_in">data</span>();</span><br><span class="line">        status = <span class="built_in">viWrite</span>(instrument,(ViBuf)ch,<span class="built_in">strlen</span>(ch),&amp;writeCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取波形数据</span></span><br><span class="line">        str = <span class="string">&quot;:TRACe:DATA? TRACE1&quot;</span>;</span><br><span class="line">        ba = str.<span class="built_in">toLatin1</span>();</span><br><span class="line">        ch = ba.<span class="built_in">data</span>();</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="number">20000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        status = <span class="built_in">viWrite</span>(instrument,(ViBuf)ch,<span class="built_in">strlen</span>(ch),&amp;writeCount);</span><br><span class="line">        status = <span class="built_in">viRead</span>(instrument, buffer,<span class="number">30000</span>, &amp;readCount);</span><br><span class="line">        str = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buffer);</span><br><span class="line">        <span class="keyword">if</span> (status == VI_SUCCESS) &#123;</span><br><span class="line">            buffer[readCount] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Read Error!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换波形数据</span></span><br><span class="line">        QStringList strList = str.<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        QVector&lt;<span class="type">double</span>&gt; x, y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strList.<span class="built_in">count</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            QString s = strList.<span class="built_in">at</span>(i);</span><br><span class="line">            <span class="type">double</span> d = s.<span class="built_in">toDouble</span>();</span><br><span class="line">            y.<span class="built_in">append</span>(d);</span><br><span class="line">            x.<span class="built_in">append</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制波形</span></span><br><span class="line">        QCustomPlot *plot = ui-&gt;plot;</span><br><span class="line">        plot-&gt;<span class="built_in">addGraph</span>();</span><br><span class="line">        plot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setData</span>(x, y);</span><br><span class="line">        plot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::red));<span class="comment">// 曲线为红色</span></span><br><span class="line">        plot-&gt;xAxis-&gt;<span class="built_in">setLabel</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        plot-&gt;yAxis-&gt;<span class="built_in">setLabel</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        plot-&gt;<span class="built_in">rescaleAxes</span>();</span><br><span class="line">        plot-&gt;<span class="built_in">setInteractions</span>(QCP::iRangeDrag|QCP::iRangeZoom|QCP::iSelectPlottables); <span class="comment">// 交互：可鼠标拖动，可滚轮缩放，可选中波形</span></span><br><span class="line">        plot-&gt;<span class="built_in">replot</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="built_in">viClose</span>(instrument);</span><br><span class="line">        <span class="built_in">viClose</span>(defaultRM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最初尝试时，经常遇到程序崩溃异常退出，最终将 <code>buffer</code> 数组拉大后得以正常，原因未知。</p><p>运行后发现波形可以显示，但横轴值不对，原因是根据代码中的 <code>x.append(i);</code> 语句，横轴数据是从 <code>0</code> 开始，步长为 <code>1</code> 的连续整数序列，因此横轴范围是 <code>0</code> 到<code>1000</code>，步长为<code>1</code>。</p><p>对转换波形数据部分进行如下修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换波形数据</span></span><br><span class="line">QStringList strList = str.<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">QVector&lt;<span class="type">double</span>&gt; x, y;</span><br><span class="line"></span><br><span class="line">QString start = ui-&gt;StartfreqEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">QString stop = ui-&gt;StopfreqEdit_2-&gt;<span class="built_in">text</span>();</span><br><span class="line"><span class="type">double</span> startX = start.<span class="built_in">toDouble</span>();<span class="comment">//  设置起始值</span></span><br><span class="line"><span class="type">double</span> stopX = stop.<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="type">double</span> step = (stopX-startX)/<span class="number">1000</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;startX;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;stopX;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;step;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;strList.<span class="built_in">count</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    QString s = strList.<span class="built_in">at</span>(i);</span><br><span class="line">    <span class="type">double</span> d = s.<span class="built_in">toDouble</span>();</span><br><span class="line">    y.<span class="built_in">append</span>(d);</span><br><span class="line">    x.<span class="built_in">append</span>(startX + i*step);<span class="comment">// 设置步长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里默认设置产生 1000 个数据点，如需修改后续可进行修改。修改后如图所示：</p><p><img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/20230424134447.png" alt="20230424134447"> </p>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> QCustomPlot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QCustomPlot 库的使用——绘制曲线</title>
      <link href="/2024/03/20/QCustomPlot%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E6%9B%B2%E7%BA%BF/"/>
      <url>/2024/03/20/QCustomPlot%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E7%BB%98%E5%88%B6%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="1- 配置库"><a href="#1- 配置库" class="headerlink" title="1. 配置库"></a>1. 配置库</h1><h2 id="1-1- 下载与预配置"><a href="#1-1- 下载与预配置" class="headerlink" title="1.1 下载与预配置"></a>1.1 下载与预配置</h2><ul><li>下载压缩包，然后吧 .cpp 和 .h 文件放入工程目录中</li><li>在 mainwindow.h 中引用下载的 .h 文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qcustomplot.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li>Q4.0 以上版本需要在 .pro 文件中加入：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += printsupport</span><br></pre></td></tr></table></figure></li><li>在 UI 设计界面，拖入 <strong>Widget</strong>, 然后右键 -&gt; 提升为…然后在弹出的对话框中，在 <strong> 提升为类名 </strong> 那里输入 QCustomPlot，然后头文件那里会自动填充为 qcustomplot.h。单击添加按钮将 QCustomPlot 加入提升类列表中，最后单击提升就可以了。</li></ul><p> <img src="https://raw.githubusercontent.com/EngineHeating/MyPicGo/main/20230405212452.png" alt="20230405212452"> </p><p> 可见，类中已经显示为 QCustomPlot。预配置完成，<strong>这个可以用来作为坐标轴画图。</strong></p><h2 id="1-2- 第一个 demo：画一个简单抛物线"><a href="#1-2- 第一个 demo：画一个简单抛物线" class="headerlink" title="1.2 第一个 demo：画一个简单抛物线"></a>1.2 第一个 demo：画一个简单抛物线 </h2><p> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成数据，画出的是抛物线</span></span><br><span class="line"><span class="function">QVector&lt;<span class="type">double</span>&gt; <span class="title">x</span><span class="params">(<span class="number">101</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">101</span>)</span></span>; <span class="comment">// 初始化向量 x 和 y</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">101</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  x[i] = i/<span class="number">50.0</span> - <span class="number">1</span>; <span class="comment">// x 范围[-1,1]</span></span><br><span class="line">  y[i] = x[i]*x[i]; <span class="comment">// y=x*x</span></span><br><span class="line">&#125;</span><br><span class="line">ui-&gt;customPlot-&gt;<span class="built_in">addGraph</span>();<span class="comment">// 添加数据曲线（一个图像可以有多个数据曲线）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// graph(0); 可以获取某个数据曲线（按添加先后排序）</span></span><br><span class="line"><span class="comment">// setData(); 为数据曲线关联数据</span></span><br><span class="line">ui-&gt;customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setData</span>(x, y);</span><br><span class="line">ui-&gt;customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setName</span>(<span class="string">&quot; 第一个示例 &quot;</span>);<span class="comment">// 设置图例名称</span></span><br><span class="line"><span class="comment">// 为坐标轴添加标签</span></span><br><span class="line">ui-&gt;customPlot-&gt;xAxis-&gt;<span class="built_in">setLabel</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">ui-&gt;customPlot-&gt;yAxis-&gt;<span class="built_in">setLabel</span>(<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="comment">// 设置坐标轴的范围，以看到所有数据</span></span><br><span class="line">ui-&gt;customPlot-&gt;xAxis-&gt;<span class="built_in">setRange</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ui-&gt;customPlot-&gt;yAxis-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ui-&gt;customPlot-&gt;legend-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>); <span class="comment">// 显示图例</span></span><br><span class="line"><span class="comment">// 重画图像, 类似于 plot 函数</span></span><br><span class="line">ui-&gt;customPlot-&gt;<span class="built_in">replot</span>();</span><br></pre></td></tr></table></figure><p>1</p>]]></content>
      
      
      <categories>
          
          <category> 信号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> QCustomPlot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库的使用</title>
      <link href="/2024/03/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2024/03/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="动态链接库的使用"><a href="# 动态链接库的使用" class="headerlink" title="动态链接库的使用"></a>动态链接库的使用 </h1><h2 id="一、在 VS 中创建动态链接库"><a href="# 一、在 VS 中创建动态链接库" class="headerlink" title="一、在 VS 中创建动态链接库"></a> 一、在 VS 中创建动态链接库 </h2><p> 首先生成的 main 文件无需改动，要做的是创建自己的 DLL 文件。分别创建头文件 .h 和源文件 .cpp。</p><p>.h 文件中如下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>extern “C”：作用是告诉编译器代码按 C 语言的方式进行编译</li><li>_declspec(dllexport)：此修饰符告诉编译器和链接器被它修饰的函数或变量需要从 DLL 导出。与其相对的代码是_declspec(dllimport) 此修饰符告诉编译器和链接器被它修饰的函数或变量需要从 DLL 导入。</li><li>int Add(int a, int b) 需要被其他程序调用的函数</li></ul><p>.cpp 文件如下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestDLL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行编译，这里无法运行是正常的。</p><h2 id="二、创建需要调用的 CPP 项目"><a href="# 二、创建需要调用的 CPP 项目" class="headerlink" title="二、创建需要调用的 CPP 项目"></a>二、创建需要调用的 CPP 项目 </h2><p> 将上步生成的 .dll 文件和 .lib 文件放入此项目根目录，将上步的 .h 文件添加进本项目。编写本 CPP 项目时，须有如下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestDLL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Dlldemo.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>main 函数如下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestDLL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;DLL1.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5+3=%d&quot;</span>, c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、动态库与静态库"><a href="# 三、动态库与静态库" class="headerlink" title="三、动态库与静态库"></a>三、动态库与静态库 </h2><p> 库有两种：<strong>静态库 </strong>（.a、.lib）和<strong> 动态库 </strong>（.so、.dll）。所谓静态、动态是指<br> 链接。</p><p>lib 是编译时需要的，dll 是运行时需要的。</p><p>如果要完成源代码的编译，有 lib 就够了。</p><p>如果也使动态连接的程序运行起来，有 dll 就够了。</p><p>在开发和调试阶段，当然最好都有。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 课后练习留档</title>
      <link href="/2024/03/20/C++%20Primer%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E7%95%99%E6%A1%A3/"/>
      <url>/2024/03/20/C++%20Primer%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E7%95%99%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Primer-Essential-C- 课后练习留档"><a href="#C-Primer-Essential-C- 课后练习留档" class="headerlink" title="C++ Primer&#x2F;Essential C++ 课后练习留档"></a>C++ Primer&#x2F;Essential C++ 课后练习留档 </h1><h2 id="第 1 章开始"><a href="# 第 1 章开始" class="headerlink" title="第 1 章开始"></a> 第 1 章开始 </h2><h3 id="练习 1-3"><a href="# 练习 1-3" class="headerlink" title="练习 1.3"></a> 练习 1.3</h3><blockquote><p>编写程序，在标准输出上打印 Hello World.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, World&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习 1-4"><a href="# 练习 1-4" class="headerlink" title="练习 1.4"></a>练习 1.4</h3><blockquote><p>我们的程序使用加法运算符 + 将两个数相加。编写程序使用乘法运算符 * 打印两个数的积。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mul1, mul2;</span><br><span class="line">std::cin &gt;&gt; mul1 &gt;&gt; mul2;</span><br><span class="line">std::cout &lt;&lt; mul1 * mul2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习 1-5"><a href="# 练习 1-5" class="headerlink" title="练习 1.5"></a>练习 1.5</h3><blockquote><p>我们将所有输出操作放在一条很长的语句中。重写程序，将每个运算对象的打印操作放在一条独立的语句中。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The number of &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; v1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; and &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; v2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; is &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习 1-6"><a href="# 练习 1-6" class="headerlink" title="练习 1.6"></a>练习 1.6</h3><blockquote><p>(非书上题)输出所有三位数的水仙花数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((i * <span class="number">100</span> + j * <span class="number">10</span> + k) == (i*i*i + j*j*j + k*k*k))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m++;</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (m &lt; <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习 -1-7"><a href="# 练习 -1-7" class="headerlink" title="练习 1.7"></a>练习 1.7</h3><blockquote><p>创建一个 txt 文件，输入两行文字并保存。编写一个程序，打开该文本文件，将其中每个字都读取到一个 vector<string>对象中。遍历 vector，将内容显示到 cout。利用泛型算法 sort()，对所有文字排序，再将排序结果输出至另一文件。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;D:\\CODE\\CPPProject\\Data\\Exercise 1.6_IN.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;D:\\CODE\\CPPProject\\Data\\Exercise 1.6_OUT.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (! infile)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Can&#x27;t find infile.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! outfile)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Can&#x27;t find outfile.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; PrintInformation;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (infile &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">PrintInformation.<span class="built_in">push_back</span>(word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PrintInformation.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; PrintInformation[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(PrintInformation.<span class="built_in">begin</span>(), PrintInformation.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; PrintInformation.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">outfile &lt;&lt; PrintInformation[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">outfile &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二章 - 面向过程的编程风格"><a href="# 第二章 - 面向过程的编程风格" class="headerlink" title="第二章 面向过程的编程风格"></a>第二章 面向过程的编程风格 </h2><h3 id="练习 -2-1"><a href="# 练习 -2-1" class="headerlink" title="练习 2.1"></a> 练习 2.1</h3><blockquote><p>编写一个函数，该函数返回斐波那契数列中用户指定的某个位置的元素。改写 main()使其允许用户不断输入位置值直到用户希望停止为止。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fibon_elem</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span>&amp; elem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="type">bool</span> more = <span class="literal">true</span>;</span><br><span class="line"><span class="type">char</span> change;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (more)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please enter a position: &quot;</span>;</span><br><span class="line">cin &gt;&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> elem;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fibon_elem</span>(pos, elem))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;element # &quot;</span> &lt;&lt; pos</span><br><span class="line">&lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Sorry.Could not calculate element # &quot;</span></span><br><span class="line">&lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;try again?(Y/N)&quot;</span>;</span><br><span class="line">cin &gt;&gt; change;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((change != <span class="string">&#x27;Y&#x27;</span>) &amp;&amp; (change != <span class="string">&#x27;y&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">more = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fibon_elem</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span>&amp; elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 检查位置是否合理</span></span><br><span class="line"><span class="keyword">if</span> (pos &lt;= <span class="number">0</span> || pos &gt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">elem = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 位置为 1、2 时 elem 值为 1</span></span><br><span class="line">elem = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n2 = <span class="number">1</span>, n1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= pos; i++)</span><br><span class="line">&#123;</span><br><span class="line">elem = n2 + n1;</span><br><span class="line">n2 = n1;</span><br><span class="line">n1 = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习 -2-2"><a href="# 练习 -2-2" class="headerlink" title="练习 2.2"></a>练习 2.2</h3><blockquote><p>Pentagonal 数列的求值公式是 $P(n)&#x3D;\frac{n(3n-1)}{2}$, 借此产生 1，5，12，22，35 等值。定义一函数，将产生的元素放到用户传入的 vector 中，元素个数由用户指定。注意检查元素个数的有效性。再编写一个函数，能将给定 vector 的所有元素一一打印出来。此函数第二参数接受一个表示数列类型的字符串。最后编写 main()测试上述两个函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 练习写的，和参考答案有出入</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;* <span class="title">pent_seq</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_size = <span class="number">1024</span>;</span><br><span class="line"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; elems;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span> || size &gt; max_size)</span><br><span class="line">&#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot; pent_seq(): oops: invalid size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; --can&#x27;t fulfill request.\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 size 小于 elems.size 就不用重新计算了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = elems.<span class="built_in">size</span>(); i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">elems.<span class="built_in">push_back</span>((i + <span class="number">1</span>) * (<span class="number">3</span> * (i + <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">const</span> string &amp;vectype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; vectype;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> string vect = <span class="string">&quot;int : &quot;</span>;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;* pseq = <span class="built_in">pent_seq</span>(<span class="number">5</span>);</span><br><span class="line">pseq = <span class="built_in">pent_seq</span>(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">display_message</span>(*pseq, vect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="练习 -2-3"><a href="# 练习 -2-3" class="headerlink" title="练习 2.3"></a>练习 2.3</h3><blockquote><p>将练习 2.2 中的 Pentagonal 数列求值函数拆分为两个函数，其中之一为 inline, 用来检验元素个数是否合理。如果合理且尚未被计算便执行第二个函数，执行求值工作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_size_ok</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; elems, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pent_seq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; elems, <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_size_ok</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; elems, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span> || size &gt; max_size)</span><br><span class="line">&#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot; pent_seq(): oops: invalid size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; --can&#x27;t fulfill request.\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; elems.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pent_seq</span>(elems, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pent_seq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; elems, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 size 小于 elems.size 就不用重新计算了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = elems.<span class="built_in">size</span>(); i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">elems.<span class="built_in">push_back</span>((i + <span class="number">1</span>) * (<span class="number">3</span> * (i + <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">const</span> string &amp;vectype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; vectype;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; elems;</span><br><span class="line"><span class="type">const</span> string vect = <span class="string">&quot;int : &quot;</span>;</span><br><span class="line"><span class="built_in">pent_seq</span>(elems, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">display_message</span>(elems, vect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习 -2-4"><a href="# 练习 -2-4" class="headerlink" title="练习 2.4"></a>练习 2.4</h3><blockquote><p>写一个函数，以局部静态的 vector 存储数列元素，返回一个 const 指针指向该 vector。若 vector 的大小小于指定元素个数，就扩充 vector 大小。接下来在事先第二个函数，接受一个位置值，返回该位置上的元素。最后编写 main 测试。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;* <span class="title">save_vec</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; vect;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = vect.<span class="built_in">size</span>(); i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">vect.<span class="built_in">push_back</span>((i + <span class="number">1</span>) * (<span class="number">3</span> * (i + <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;vect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pent_elem</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;* pseq = <span class="built_in">save_vec</span>(pos);</span><br><span class="line"><span class="keyword">if</span> (!pseq)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (*pseq)[pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">pent_elem</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="string">&quot;The number is &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP 基础</title>
      <link href="/2024/03/20/CPP%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/20/CPP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="# 基础知识" class="headerlink" title="基础知识"></a>基础知识 </h2><p> 在基础知识部分，好像只有头文件的引用和输入输出函数发生了变化。</p><p>头文件下加入<code>using namespace std;</code></p><p><code>#include&lt;stdio.h&gt;——&gt;#include&lt; iostream&gt;</code></p><p><code>printf——&gt;cout</code></p><p><code>scanf——&gt;cin</code></p><p>C++ 有字符串类型 string , 这是 C 语言所不具备的。</p><h2 id="数组——Array 和 Vector"><a href="# 数组——Array 和 Vector" class="headerlink" title="数组——Array 和 Vector"></a>数组——Array 和 Vector</h2><ul><li>Array 即为常用数组，Vector 需要包含 vector 头文件。</li><li>为 Vector 赋值时，不能用初始化列表，必须一个一个赋值。</li><li>Vector 可以使用 <code>.size</code> 返回数组大小。</li></ul><h2 id="指针"><a href="# 指针" class="headerlink" title="指针"></a>指针 </h2><h3 id="基础概念"><a href="# 基础概念" class="headerlink" title="基础概念"></a> 基础概念</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;             <span class="comment">// 假设 a 的地址为 1000</span></span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p>这是定义了一个指向 int 形变量 a 的指针。此时<code>p = &amp;a = 1000</code>,<code>*p = a = 10</code>。</p><blockquote><p>&amp;：取址运算符，取 &amp; 后面的变量的地址值。</p><p>*： 取值运算符：取 * 后面的地址里保存的变量值。</p></blockquote><h3 id="指针传入函数"><a href="# 指针传入函数" class="headerlink" title="指针传入函数"></a>指针传入函数 </h3><p> 调用一个函数时，通常不会将变量直接传入函数，而是将调用的变量复制一份副本传入函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 没用指针，交换失败</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a:10</span></span><br><span class="line"><span class="comment">//b:20</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a:20</span></span><br><span class="line"><span class="comment">//b:10</span></span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="# 指针和数组" class="headerlink" title="指针和数组"></a>指针和数组 </h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">5</span>];   <span class="comment">// 假设 b[0] 地址为 1500，则 b[1]地址为 1504……</span></span><br></pre></td></tr></table></figure><p>不能对 b 进行别的操作，想要用指针对数组进行操作，需定义一个新的指针指向这个数组，如：<code>int *pb = &amp;b[0];</code>. 如果此时进行<code>pb++</code>，则<code>pb = &amp;b[1]</code>。</p><h2 id="文件的读写"><a href="# 文件的读写" class="headerlink" title="文件的读写"></a>文件的读写 </h2><p> 对文件读写首先需要包含 <code>fstream</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后是定义输入 &#x2F; 输出对象，传入文件名（地址）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;D:\\Exercise 1.6_IN.txt&quot;</span>)</span></span>;<span class="comment">// 文件读入</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;D:\\Exercise 1.6_OUT.txt&quot;</span>)</span></span>;<span class="comment">// 文件输出</span></span><br><span class="line">   <span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">&quot;D:\\Exercise 1.6_IO.txt&quot;</span>)</span></span>;<span class="comment">// 同时读写一个文件</span></span><br></pre></td></tr></table></figure><p>这种情况下，如果没有该文件，会自动创建；如果有该文件，会自动清空并写入新内容。如果不想清空，需要设置追加模式（append mode）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;D:\\Exercise 1.6_OUT.txt&quot;</span>,ios_base::app)</span></span>;<span class="comment">// 文件输出, 追加模式</span></span><br></pre></td></tr></table></figure><ul><li>练习 1.7</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP 核心编程</title>
      <link href="/2024/03/20/CPP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/03/20/CPP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一章内容基于视频 84-90 节内容，第二章后内容基于 Essential C++.</p></blockquote><h2 id="1- 内存分区模型"><a href="#1- 内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++ 程序执行时，将内存大致分为 4 个区域：</p><ul><li>代码区</li><li>全局区</li><li>栈区</li><li>堆区</li></ul><h3 id="1-1- 程序运行前"><a href="#1-1- 程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前 </h3><p> 程序编译后，生成了 exe 可执行文件，未执行该程序前分为两个区域：</p><p>代码区：</p><ul><li>存放 CPU 执行的机器指令</li><li>代码区是 <strong> 共享 </strong> 的。对于被频繁执行的程序，只需存储一份代码</li><li>代码区是 <strong> 只读 </strong> 的。防止程序意外修改它的指令。</li></ul><p>全局区：</p><ul><li>存放全局变量(函数外定义的变量)、静态变量（static）、常量（3 种）</li><li>该区域数据程序结束后由操作系统释放。</li></ul><h3 id="1-2- 程序运行后"><a href="#1-2- 程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后 </h3><p> 栈区：</p><ul><li>编译器自动分配释放，存放函数的参数值，局部变量等；</li><li>注：不要返回局部变量的地址。</li></ul><p>堆区：</p><ul><li>堆区数据由程序员管理和释放</li><li>堆区数据由 new 关键字开辟内存<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-new 运算符"><a href="#1-3-new 运算符" class="headerlink" title="1.3 new 运算符"></a>1.3 new 运算符 </h3><p> 在堆区开辟数据，由 delete 释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 分配 10 个 int 数据组成的数组，arr 指针指向第一个 Int</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;   <span class="comment">//arr 必须指向一个动态分配的数组或者为空</span></span><br></pre></td></tr></table></figure><h3 id="1-4- 引用"><a href="#1-4- 引用" class="headerlink" title="1.4 引用"></a>1.4 引用 </h3><h4 id="1-4-1- 基本操作"><a href="#1-4-1- 基本操作" class="headerlink" title="1.4.1 基本操作"></a>1.4.1 基本操作</h4><p> 作用：给变量起别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">// 给 a 起一个别名为 b</span></span><br></pre></td></tr></table></figure><ul><li>引用必须初始化</li><li>引用一经初始化后不可更改</li></ul><h4 id="1-4-2- 引用做函数参数及返回值"><a href="#1-4-2- 引用做函数参数及返回值" class="headerlink" title="1.4.2 引用做函数参数及返回值"></a>1.4.2 引用做函数参数及返回值 </h4><p><strong> 作用</strong>：函数传参时，可以用引用让形参修饰实参，简化指针修改实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">find</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> value)</span><span class="comment">//vec 代表对 vec 这个 vector 的引用，避免拷贝整个 vector</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ix = <span class="number">0</span>; ix &lt; vec.size; ++ix)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[ix] == value)</span><br><span class="line">            <span class="keyword">return</span> &amp;vec[ix];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不要返回局部变量引用</p><h2 id="2- 面向过程的编程风格"><a href="#2- 面向过程的编程风格" class="headerlink" title="2 面向过程的编程风格"></a>2 面向过程的编程风格 </h2><h3 id="2-1- 编写函数"><a href="#2-1- 编写函数" class="headerlink" title="2.1 编写函数"></a>2.1 编写函数</h3><p> 函数必须先被声明，然后才能被调用。</p><p>如果函数返回类型不为 void，那它必须在每个可能的退出点上将值返回。</p><h3 id="2-2- 调用函数"><a href="#2-2- 调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数 </h3><p> 当调用一个函数时，会在内存中建立起一块特殊区域，称为“<strong>程序堆栈</strong>”。这块区域提供了每个函数参数的存储空间。他也提供了函数所定义的每个对象的内存空间，称为局部对象。一旦函数完成，这块内存会被释放掉。</p><h4 id="2-2-1-Pass-by-Reference 语义"><a href="#2-2-1-Pass-by-Reference 语义" class="headerlink" title="2.2.1 Pass by Reference 语义"></a>2.2.1 Pass by Reference 语义</h4><p><strong>reference</strong>: 引用，见 1.4 节。</p><p>当我们以 by reference 方式将对象作为函数参数传入时，对象本身并不会复制出另一份，<strong>复制的是对象的地址。</strong></p><p>将函数声明为 reference (引用)的理由：</p><ul><li>希望直接对传入对象进行修改</li><li>降低复制大型对象的额外负担</li></ul><p>例如，将 vector 以传值方式传入 display() 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">display</span>(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中由于函数中不会更改 vector 的内容，故少了 const 不会有错误，但加上 const 可以让阅读程序的人了解，我们用传址的方式传递 vector。</p><p><strong>pointer</strong>: 以 pointer 形式传递的效果相同，唯一差别在于用法不同。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; *vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">display</span>(&amp;vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2- 作用域及范围"><a href="#2-2-2- 作用域及范围" class="headerlink" title="2.2.2 作用域及范围"></a>2.2.2 作用域及范围 </h4><p> 为对象分配的内存，其存活时间称为 <strong> 储存期 </strong> 或<strong>范围 </strong>。每次函数执行，会为函数内变量分配内存，函数结束便会释放。我们称此对象具有<strong> 局部性范围</strong>。</p><p>对象在程序内的存活区域称为该对象的 <strong> 作用域</strong>(scope)。</p><ul><li>局部作用域(local scope)：名称在 local scope 以外不可见。</li><li>file scope：从其声明点至文件末尾都可见。</li></ul><h4 id="2-2-3- 动态内存管理"><a href="#2-2-3- 动态内存管理" class="headerlink" title="2.2.3 动态内存管理"></a>2.2.3 动态内存管理 </h4><p> 见第 1 章。</p><h3 id="2-3- 提供默认参数值"><a href="#2-3- 提供默认参数值" class="headerlink" title="2.3 提供默认参数值"></a>2.3 提供默认参数值</h3><p>C++ 允许我们为全部或部分参数设定默认值。如下例所示，指定 ofstream 指针默认值为 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span> &amp;vec&gt;, ofstream *ofil = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;···&#125;<span class="comment">// 必须是 pointer 而非 reference，因为 reference 无法被设置为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种让 cout 称为默认的 ofstream 参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec, ofstream &amp;os = cout)</span></span></span><br><span class="line"><span class="function"></span>&#123;···&#125;</span><br></pre></td></tr></table></figure><ul><li>默认值操作必须由最右边开始进行，即提供默认值参数的右侧参数必须具有默认值。</li><li>默认值只能指定一次。为了更高可见性，一般可将默认值放在开头的函数声明处而非定义处。</li></ul><h3 id="2-4- 使用局部静态对象"><a href="#2-4- 使用局部静态对象" class="headerlink" title="2.4 使用局部静态对象"></a>2.4 使用局部静态对象 </h3><p> 定义在函数中的局部静态对象，其所处的内存空间，即使在不同的函数调用过程中，依然持续存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fibon_seq</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">int</span>&gt; elems;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5- 声明 inline 函数"><a href="#2-5- 声明 inline 函数" class="headerlink" title="2.5 声明 inline 函数"></a>2.5 声明 inline 函数 </h3><p> 将函数声明为 <strong>inline（内联）</strong>，表示要求编译器在每个函数调用点上将函数的内容展开。对一个 inline 函数，编译器可 <strong> 选择 </strong> 将该函数的调用操作改为以一份函数代码副本代替。相当于将函数写入进来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">fibon_elem</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> &amp;elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;···&#125;</span><br></pre></td></tr></table></figure><p>适合声明为 inline 的函数：体积小，常被调用，所从事的计算不复杂。</p><h3 id="2-6- 提供重载函数"><a href="#2-6- 提供重载函数" class="headerlink" title="2.6 提供重载函数"></a>2.6 提供重载函数 </h3><p> 有时我们需要一个通用的函数，其传入的参数的类型和数量可能不尽相同，此时需要通过 <strong> 函数重载 </strong> 机制实现。</p><p>参数列表不相同的多个函数，可以拥有相同的函数名称。编译器会将调用者提供的实际参数拿来和每个重载函数的参数比对，找出其中最合适的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>编译器 <strong> 无法根据函数的不同的返回类型 </strong> 来区分两个相同名称的函数。</p><p>将一组实现代码不同但工作内容相似的函数加以重载，可以让函数用户更容易使用这些函数，也使得我们不需要对类似函数进行多个命名。</p><h3 id="2-7- 定义模板函数"><a href="#2-7- 定义模板函数" class="headerlink" title="2.7 定义模板函数"></a>2.7 定义模板函数 </h3><p> 如果我们希望程序代码的主体不变，仅仅改变其中用到的数据类型，可以通过 <strong> 函数模板 </strong>(function template) 将参数列表中的指定参数的类型信息抽离出来。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_message</span><span class="params">(<span class="type">const</span> string&amp; msg, <span class="type">const</span> vector&lt;elemType&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cont &lt;&lt; msg;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.size; i++)</span><br><span class="line">&#123;</span><br><span class="line">elemType t = vec[i];</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数模板时，只需将 elemType 换为对应的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; ivec;</span><br><span class="line">string msg;</span><br><span class="line"><span class="built_in">display_message</span>(msg, ivec);</span><br></pre></td></tr></table></figure><h3 id="2-8- 函数指针"><a href="#2-8- 函数指针" class="headerlink" title="2.8 函数指针"></a>2.8 函数指针 </h3><p> 现在假如有一组“通过 vector 返回六种数列”的函数如：<code>const vector&lt;int&gt; *fibon_seq(int size)</code>，现在需要实现找到指定数列的指定数值的函数。如果我们不想再定义 6 个不同的函数，那就需要使用 <strong> 函数指针 </strong> 实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;* (*seq_ptr)(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>函数指针必须指明函数的返回类型 <code>const vector&lt;int&gt;*</code> 和参数列表 <code>int</code>。（*seq_ptr) 中 * 表示是一个指针变量，seq_ptr 是这个变量的名称。</p><p>要取得函数的地址，直接赋值函数的名称即可。</p><h3 id="2-9- 设定头文件"><a href="#2-9- 设定头文件" class="headerlink" title="2.9 设定头文件"></a>2.9 设定头文件 </h3><p> 把函数声明放在头文件中，以供多个程序文件调用。</p><p>对象的定义需要前加关键字 <strong>extern</strong>。</p><h2 id="3- 泛型编程风格"><a href="#3- 泛型编程风格" class="headerlink" title="3 泛型编程风格"></a>3 泛型编程风格 </h2><h3 id="3-1- 指针的算术运算"><a href="#3-1- 指针的算术运算" class="headerlink" title="3.1 指针的算术运算"></a>3.1 指针的算术运算</h3><p> 我们希望在一个函数中可以处理任意数据类型，包括 vector 和 array。</p><p>当数组被传递给函数，或从函数中返回时，仅有第一个元素的地址会被传递。因此一般都是传入指向数组的指针，以便对 array 进行读取操作。<br>如：<code>int min(int *array)&#123;···&#125;</code></p><p>当我们以指针指向 array 第一个元素的方式传入函数时，仍然可以通过下标运算符 [] 访问每个元素，<strong>就如同此 array 是个对象一般。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">2</span>];</span><br><span class="line">*(array + <span class="number">2</span>);<span class="comment">// 两种方式都返回 array 第三个元素</span></span><br></pre></td></tr></table></figure><p>注意，vector 可以为空，array 则不然。</p><p>指针的算数运算 <strong> 必须先假设所有元素存储在连续空间里</strong>，然后才能根据当前的指针，加上元素大小后，指向下一个元素。</p><p><strong>list</strong> 也是一个容器，其连接方式为双向链表。</p><p>但由于 list 存储的元素并不处在一片连续的空间，假设要实现 find()函数，原有的指针操作在 list 容器无法实现。由此引出 <strong>Iterator 泛型指针</strong> 概念，把底层指针的处理放在此抽象层中，让用户无须直接面对指针操作。</p><h3 id="3-2- 了解 Iterator- 泛型指针"><a href="#3-2- 了解 Iterator- 泛型指针" class="headerlink" title="3.2 了解 Iterator(泛型指针)"></a>3.2 了解 Iterator(泛型指针)</h3><p>泛型指针（iterator）（又称迭代器）很像指针，但又有一些新特性。我们需要 <code>iterator</code> 在被定义时有看到如下特性：</p><ul><li>迭代对象（某个容器）的类型，这可以决定如何访问下一个元素。（比如 vector 和 list 的区别）</li><li>iteraotr 所指的元素类型，这可以决定 iterator 提领操作（*）的返回值。</li></ul><p>定义 iterator：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">vector&lt;string&gt;::iterator iter = svec.<span class="built_in">begin</span>();   <span class="comment">// 双冒号代表此 iterator 是位于 string vector 定义内的嵌套类型。</span></span><br></pre></td></tr></table></figure><p>对于对 const vector 进行遍历操作：注意 const_iterator 指针值是可变的，但其指向的元素不可变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;string&gt; cs_vec;</span><br><span class="line">vector&lt;string&gt;::const_iterator iter = cs_vec.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>欲通过 iterator 取得元素值，和指针一样进行提领操作即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *iter;</span><br></pre></td></tr></table></figure><p>根据以上规则，重写 display 函数，使 iterator 代替 subscript（下标）（ps: 就是数组后的[]）:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt; <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> vector&lt;elemType&gt;&amp; vec, ostream&amp; os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;elemType&gt;::const_iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;elemType&gt;::const_iterator end_it = vec.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; iter != end_it; ++iter)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; *iter &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">os &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在重新实现<code>find()</code>, 使其同时支持两种形式：一对指针，或是一对指向某种容器的 iterator.</p><blockquote><p>假如用户希望赋予 equaily 运算符不同的意义，需要增强 find()的弹性。为此，下一步要将现有的 find()演化为泛型算法。</p></blockquote><h3 id="3-3- 所有容器的共通操作"><a href="#3-3- 所有容器的共通操作" class="headerlink" title="3.3 所有容器的共通操作"></a>3.3 所有容器的共通操作 </h3><p> 共通操作：</p><ul><li><code>==</code>和<code>！=</code></li><li><code>=</code></li><li><code>empty()</code></li><li><code>size()</code></li><li><code>clear()</code></li></ul><p>除此之外，每个容器还包括：<code>begin()</code>和 <code>end()</code>;<code>insert()</code> 和<code>erase()</code>.</p><h3 id="3-4- 使用顺序性容器"><a href="#3-4- 使用顺序性容器" class="headerlink" title="3.4 使用顺序性容器"></a>3.4 使用顺序性容器 </h3><p> 顺序性容器主要有<code>vector</code>,<code>list</code>,<code>deque</code>（双端队列，类似于 vector, 但可对头元素进行插入、删除操作）。</p><p>上三种容器均有两个特别操作函数：<code>push_back()</code>和 <code>pop_back()</code>. 用来在末端插入 &#x2F; 删除一个元素。其中 list 和 deque 还有针对头部的<code>push_front()</code> 和<code>pop_front</code></p><h3 id="3-5- 使用泛型算法"><a href="#3-5- 使用泛型算法" class="headerlink" title="3.5 使用泛型算法"></a>3.5 使用泛型算法 </h3><p> 使用算法需要包含 algorithm 头文件。</p><h3 id="3-6- 如何设计一个泛型算法"><a href="#3-6- 如何设计一个泛型算法" class="headerlink" title="3.6 如何设计一个泛型算法"></a>3.6 如何设计一个泛型算法</h3><blockquote><p>新任务是，在原有的找到小于某个数的函数的基础上，能使用户指定不同的比较操作。为此需要将“比较操作”参数化。</p></blockquote><p><code>function object</code> : 某种 class 的实例对象，这类 class 对 function call 运算符做了重载操作（？），<strong>可使 function object 被当作一般函数来使用。</strong></p><p><code>function object Adapter</code>: 函数对象适配器（？）</p><p>这里以 less<type>为例，取代了原本的函数指针，使用时 <code>less&lt;int&gt;</code> 和 bind1st&#x2F;bind2nd 结合使用，如 bind2nd 会指定值 (是 val?) 绑定至第二操作数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">filter_ver2</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> val,<span class="type">const</span> less&lt;<span class="type">int</span>&gt;&amp; lt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nvec;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((iter = <span class="built_in">find_if</span>(iter, vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(lt, val))) != vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">nvec.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">iter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nvec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7- 使用 Map"><a href="#3-7- 使用 Map" class="headerlink" title="3.7 使用 Map"></a>3.7 使用 Map</h3><p>Map 类型是多个一对值，即 key-value 的组合。</p><h3 id="3-8- 使用 Set"><a href="#3-8- 使用 Set" class="headerlink" title="3.8 使用 Set"></a>3.8 使用 Set</h3><p>Set 类型一群 key 组合而成。</p><h3 id="3-9- 如何使用 Iterator-Inserter"><a href="#3-9- 如何使用 Iterator-Inserter" class="headerlink" title="3.9 如何使用 Iterator Inserter"></a>3.9 如何使用 Iterator Inserter</h3><p>这节主要讲了三个 insertion adapter，用来取代 assignment（赋值）操作符，如 back_inserter，他用 push.back()函数取代赋值操作符，这样就不用一开始就指定好目标容器（可能是用于存放复制后的数据）。</p><h3 id="3-10- 使用 iostream-Iterator"><a href="#3-10- 使用 iostream-Iterator" class="headerlink" title="3.10 使用 iostream Iterator"></a>3.10 使用 iostream Iterator</h3><p>这节主要讲了两个有关输入输出的 Iterator:istream_iterator 和 ostream_iterator，可支持单一类型的元素读取和写入。</p><p>对于输入，其 last <strong>iterator</strong>不指定对象即可，这可以代表 last 是“要读取的最后一个元素的下一位置”。</p><h2 id="4- 基于对象的编程风格"><a href="#4- 基于对象的编程风格" class="headerlink" title="4 基于对象的编程风格"></a>4 基于对象的编程风格 </h2><h3 id="4-1- 如何实现一个 Class"><a href="#4-1- 如何实现一个 Class" class="headerlink" title="4.1 如何实现一个 Class"></a>4.1 如何实现一个 Class</h3><p> 本节以实现一个 Stack 类为引子介绍如何写一个最简单的 Class. 实现一个 Class 主要分为两部分：.h 文件和.cpp 文件。其中，.h 文件包含对该 Class 的定义；.cpp 包含了 member function 的具体定义。（当然也可以在 class 主体内定义）</p><p>Stack Class 定义的主体壳子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(string&amp; elem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">peek</span><span class="params">(string&amp; elem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _stack.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> string &amp;value)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;string&gt; _stack;<span class="comment">// 习惯上给 private 变量加下划线</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在.cpp 定义 member function 时，要注意使用如下语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">pop</span>(); <span class="comment">//:: 类作用域解析符告诉了编译器这是 Stack class 的一个 member。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/20/hello-world/"/>
      <url>/2024/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
