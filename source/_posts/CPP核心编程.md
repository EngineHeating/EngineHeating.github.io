---
title: CPP核心编程
date: 2024-03-20 14:39:17
tags:
    - 学习笔记
    - C++
---

> 第一章内容基于视频84-90节内容，第二章后内容基于Essential C++.
## 1 内存分区模型
C++程序执行时，将内存大致分为4个区域：
- 代码区
- 全局区
- 栈区
- 堆区

### 1.1 程序运行前
程序编译后，生成了 exe 可执行文件，未执行该程序前分为两个区域：

代码区：

- 存放CPU执行的机器指令
- 代码区是**共享**的。对于被频繁执行的程序，只需存储一份代码
- 代码区是**只读**的。防止程序意外修改它的指令。

全局区：
- 存放全局变量(函数外定义的变量)、静态变量（static）、常量（3种）
- 该区域数据程序结束后由操作系统释放。

### 1.2 程序运行后
栈区：
- 编译器自动分配释放，存放函数的参数值，局部变量等；
- 注：不要返回局部变量的地址。

堆区：
- 堆区数据由程序员管理和释放
- 堆区数据由new关键字开辟内存
```cpp
int *p = new int(10);
```

### 1.3 new运算符
在堆区开辟数据，由 delete 释放。
```cpp
int *arr = new int[10]; //分配10个int数据组成的数组，arr指针指向第一个Int
delete[] arr;   //arr必须指向一个动态分配的数组或者为空
```

### 1.4 引用
#### 1.4.1 基本操作
作用：给变量起别名
```cpp
int a = 10;
int &b = a; //给a起一个别名为b
```
- 引用必须初始化
- 引用一经初始化后不可更改

#### 1.4.2 引用做函数参数及返回值
**作用**：函数传参时，可以用引用让形参修饰实参，简化指针修改实参。

**注意**：不要返回局部变量引用

## 2 面向过程的编程风格
### 2.1 编写函数
函数必须先被声明，然后才能被调用。

如果函数返回类型不为 void，那它必须在每个可能的退出点上将值返回。

### 2.2 调用函数
当调用一个函数时，会在内存中建立起一块特殊区域，称为“**程序堆栈**”。这块区域提供了每个函数参数的存储空间。他也提供了函数所定义的每个对象的内存空间，称为局部对象。一旦函数完成，这块内存会被释放掉。

### 2.2.1 Pass by Reference语义

**reference**:引用，见1.4节。

当我们以 by reference 方式将对象作为函数参数传入时，对象本身并不会复制出另一份，**复制的是对象的地址。**

将函数声明为 reference (引用)的理由：
- 希望直接对传入对象进行修改
- 降低复制大型对象的额外负担

例如，将 vector 以传值方式传入 display() 中：
```CPP
void display(const vector<int> &vec)
{···}
int main()
{
    display(vec);
}
```
本例中由于函数中不会更改 vector 的内容，故少了 const 不会有错误，但加上 const 可以让阅读程序的人了解，我们用传址的方式传递 vector。

**pointer**: 以 pointer 形式传递的效果相同，唯一差别在于用法不同。如：
```CPP
void display(const vector<int> *vec)
{···}
int main()
{
    display(&vec);
}
```

### 2.2.2 作用域及范围
为对象分配的内存，其存活时间称为**储存期**或**范围**。每次函数执行，会为函数内变量分配内存，函数结束便会释放。我们称此对象具有**局部性范围**。

对象在程序内的存活区域称为该对象的**作用域**(scope)。
- 局部作用域(local scope)：名称在 local scope 以外不可见。
- file scope：从其声明点至文件末尾都可见。

### 2.2.3 动态内存管理
见第 1 章。