---
title: LeetCode | 59.螺旋矩阵II
date: 2025-02-19 11:21:11
categories:
  - CPP
  - LeetCode
tags:
  - C++
  - 算法
---
# LeetCode | 59.螺旋矩阵II
## 题目
[力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/description/)

给定一个正整数  *n*，生成一个包含 1 到  *n*<sup>2</sup>  所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**示例:**

<pre><strong>输入:</strong> 3
<strong>输出:</strong>
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]</pre>

## 思路
首先思考螺旋规律。取n=1~5尝试初步发现以下规律：
- 第一次一定向右填n个数。
- 随后一定是按“下左”“上右”的顺序填数字。n=2时，只有一次下左，没有上右。
- 每进行一次“下左”/“上右”，下次进行“上右”/“下左”要填的数都比上一轮少1
- 根据四种填数方向改变i,j值

## 问题
- vector二维数组的操作

    初始化一个vector二维数组如下：
    ```CPP
    vector<vector<int>> table(m, vector<int>(n,0))  //定义了m个一维vector数组，每个数组长度为n，初始化为0
    int row = table.size();      //获取行数
    int column = table[0].size();//获取列数
    ```
    这样等效于定义了一个m行n列的数组。
- 第一次提交错误
  
    for循环中需更换的变量错误。之前用当前i,j值作为循环变量并≤n，当螺旋越来越“向内部”时，此时i,j非零，可能i,j在循环开始已经超过n（n是递减的会越来越小）

- 另一种思路

    题解的思路是，每个循环都进行一次右下左上的操作，考虑边界时，注意每次少填一个数，例如n=3时，每条边就一次填2个数。最后在考虑n为奇数时填中间数。


## AC代码
```CPP
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int dir = 0;  // 输入元素方向，下左对应0,上右对应1
        int currentI = 0;
        int currentJ = 0;
        int value = 1;
        int i = 0;
        int k = 0;
        vector<vector<int>> output(n, vector<int>(n,0));
        for(currentJ = 0; currentJ < n; currentJ++)
        {
            output[0][currentJ] = value++; 
        }
        n--;
        currentJ --;
        currentI ++;
        for (;n > 0;)
        {
            if(!dir)
            {
                //如果dir为0，则为下左，否则为上右
                for(i = 0; i < n; i++)
                {
                    output[currentI++][currentJ] = value++;
                }
                currentI--;
                currentJ--;

                for(i = 0; i < n; i++)
                {
                    output[currentI][currentJ--] = value++;
                }
                currentJ++;
                currentI--;
                dir = 1;
                n--;
                k++;
            }
            else
            {
                for(i = 0; i < n; i++)
                {
                    output[currentI--][currentJ] = value++;
                }
                currentI++;
                currentJ++;
                for(i = 0; i < n; i++)
                {
                    output[currentI][currentJ++] = value++;
                }
                currentJ--;
                currentI++;
                dir = 0;
                n--;
            }
        }
        return output;
    }
};
```