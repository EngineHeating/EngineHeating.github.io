---
title: LeetCode | 904.水果成篮
date: 2025-02-14 15:56:12
categories:
  - CPP
  - LeetCode
tags:
  - C++
  - 算法
---
# LeetCode | 904.水果成篮
## 题目
[力扣题目链接](https://leetcode.cn/problems/fruit-into-baskets/)

在一排树中，第 `i` 棵树产生  `tree[i]` 型的水果。  
你可以**从你选择的任何树开始**，然后重复执行以下步骤：

1.  把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。
2.  移动到当前树右侧的下一棵树。如果右边没有树，就停下来。

请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。

你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。

用这个程序你能收集的水果树的最大总量是多少？

**示例 1：**

<pre><strong>输入：</strong>[1,2,1]
<strong>输出：</strong>3
<strong>解释：</strong>我们可以收集 [1,2,1]。
</pre>

**示例 2：**

<pre><strong>输入：</strong>[0,1,2,2]
<strong>输出：</strong>3
<strong>解释：</strong>我们可以收集 [1,2,2]
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
</pre>

**示例 3：**

<pre><strong>输入：</strong>[1,2,3,2,2]
<strong>输出：</strong>4
<strong>解释：</strong>我们可以收集 [2,3,2,2]
如果我们从第一棵树开始，我们将只能收集到 [1, 2]。
</pre>

**示例 4：**

<pre><strong>输入：</strong>[3,3,3,1,2,1,1,2,3,3,4]
<strong>输出：</strong>5
<strong>解释：</strong>我们可以收集 [1,2,1,1,2]
如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。
</pre>

**提示：**

- `1 <= tree.length <= 40000`
- `0 <= tree[i] < tree.length`

## 思路
题目的本质是：找到最长的一个子数组，此子数组的元素种类≤2。

基于**双指针**的思想实现。定义快慢两个指针，再定义两个int变量`fruit_first`和`fruit_second`分别存放当前子数组的两类水果，初始化为-1代表还没摘水果。再定义两个`output_first`和`output_second`存放输出数组长度。

然后让判断每个快指针对应值是否等于当前存放的两类水果，如果有，说明当前子数组种类仍然≤2，令`output_first`加1。

一旦快指针发现第三种水果，此时将当前子数组长度存到`output_second`中，修改当前存放的两种水果类型为fast指针和fast-1指针的水果。（此时fast指针和fast-1指针一定是两种水果）并令slow指针指向fast-1。重新令`output_first = 1`，令slow指针向左移动，直到出现不同种类的水果为止之前都令`output_first`自增。

如此一来，发现第三种水果并经过如上处理后，在快指针重新向右移动前，就可以得到新的子数组的当前长度。

## AC代码
```CPP
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int output_first = 0;
        int output_second = 0;
        int point_slow = 0;
        int point_fast = 0;
        int fruit_first = -1;
        int fruit_second = -1;
        for(;point_fast < fruits.size();)
        {
            if(fruit_first == -1 || fruits[point_fast] == fruit_first)
            {
                fruit_first = fruits[point_slow];
                output_first = output_first + 1;
                point_fast++;
            }
            else if (fruit_second == -1 || fruits[point_fast] == fruit_second)
            {
                fruit_second = fruits[point_fast++];
                output_first = output_first + 1;
            }
            else
            {
                    fruit_first = fruits[point_fast - 1];
                    fruit_second = fruits[point_fast];
                    output_second = max(output_first,output_second);

                    point_slow = point_fast - 1;
                    output_first = 1;
                    do{
                        output_first = output_first + 1;
                        point_slow--;
                    }while(fruits[point_slow] == fruit_first);
                    point_fast++;
                    point_slow++;
            }

        }
        return max(output_first,output_second);
    }
};
```