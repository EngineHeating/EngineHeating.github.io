---
title: LeetCode | 54.螺旋矩阵II
date: 2025-02-24 16:45:11
categories:
  - CPP
  - LeetCode
tags:
  - C++
  - 算法
---
# LeetCode | 54.螺旋矩阵
## 题目
[力扣题目链接](https://leetcode.cn/problems/spiral-matrix/description/)

给定一个包含  *m* x *n*  个元素的矩阵（_m_ 行, _n_ 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例  1:**

<pre><strong>输入:</strong>
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
<strong>输出:</strong> [1,2,3,6,9,8,7,4,5]
</pre>

**示例  2:**

<pre><strong>输入:</strong>
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
<strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]
</pre>

## 思路
紧接着[螺旋矩阵II](https://leetcode.cn/problems/spiral-matrix/description/)的问题。模拟思路和n阶方阵是一样的，即使变为了m行n列矩阵，仍然是**右下左上**的规律，具体用了上题的官方思路。

## 问题

- 第一次提交错误
  
    方向左和上的时候，循环判断为`for(;j > offset; j--)`,事实上应为`;j > offset - 1; j--`



## AC代码
```CPP
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> output;
        int m = matrix.size();
        int n = matrix[0].size(); 
        int startX = 0;
        int startY = 0;
        int i = 0;
        int j = 0;
        int mid = min(m, n);
        int loop = min(m, n) / 2;   //循环次数
        int offset = 1; //定义边界应去掉offset个输出变量，每次循环此值加1
        while(loop--)
        {
            i = startX;
            j = startY;
            for(;j < n - offset; j++)
            {
                output.push_back(matrix[i][j]);
            }
            for(;i < m - offset; i++)
            {
                output.push_back(matrix[i][j]);
            }
            for(;j > offset - 1; j--)
            {
                output.push_back(matrix[i][j]);    
            }
            for(;i > offset - 1; i--)
            {
                output.push_back(matrix[i][j]);    
            }
            startX++;
            startY++;
            offset++;
        }
        if(mid % 2)
        {
            i = startX;
            j = startY;
            if(m <= n)
            {
                for(;j < n - offset + 1; j++)
                {
                    output.push_back(matrix[i][j]);   
                }
            }
            else
            {
                for(;i < m - offset + 1; i++)
                {
                    output.push_back(matrix[i][j]);   
                }                
            }
        }
        return output;
    }
};
```